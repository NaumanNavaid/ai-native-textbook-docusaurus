<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-part-4-perception/chapter-16-path-planning-algorithms" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.9.2">
<title data-rh="true">Path Planning Algorithms | Physical AI &amp; Humanoid Robotics</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Path Planning Algorithms | Physical AI &amp; Humanoid Robotics"><meta data-rh="true" name="description" content="16.1 Path Planning Fundamentals"><meta data-rh="true" property="og:description" content="16.1 Path Planning Fundamentals"><link data-rh="true" rel="icon" href="/ai-native-textbook-docusaurus/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms"><link data-rh="true" rel="alternate" href="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms" hreflang="en"><link data-rh="true" rel="alternate" href="https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms" hreflang="x-default"><script data-rh="true" type="application/ld+json">{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Path Planning Algorithms","item":"https://NaumanNavaid.github.io/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms"}]}</script><link rel="alternate" type="application/rss+xml" href="/ai-native-textbook-docusaurus/blog/rss.xml" title="Physical AI &amp; Humanoid Robotics RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ai-native-textbook-docusaurus/blog/atom.xml" title="Physical AI &amp; Humanoid Robotics Atom Feed"><link rel="stylesheet" href="/ai-native-textbook-docusaurus/assets/css/styles.5f9a55e0.css">
<script src="/ai-native-textbook-docusaurus/assets/js/runtime~main.809c45bc.js" defer="defer"></script>
<script src="/ai-native-textbook-docusaurus/assets/js/main.dc2a0ec6.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<svg style="display: none;"><defs>
<symbol id="theme-svg-external-link" viewBox="0 0 24 24"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"/></symbol>
</defs></svg>
<script>!function(){var t=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();document.documentElement.setAttribute("data-theme",t||(window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light")),document.documentElement.setAttribute("data-theme-choice",t||"system")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav class="nm-custom-navbar"><div class="nm-navbar-container"><div class="nm-navbar-logo"><a class="nm-logo-link" href="/ai-native-textbook-docusaurus/"><div class="nm-logo-icon"><svg width="32" height="32" viewBox="0 0 32 32" fill="none"><rect width="32" height="32" rx="8" fill="currentColor"></rect><path d="M8 16C8 11.5817 11.5817 8 16 8C20.4183 8 24 11.5817 24 16C24 20.4183 20.4183 24 16 24C11.5817 24 8 20.4183 8 16Z" fill="var(--ifm-background-color)"></path><path d="M12 16L16 12L20 16M16 12V20" stroke="var(--ifm-color-primary)" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"></path></svg></div><div class="nm-logo-text"><span class="nm-logo-title">Physical AI</span><span class="nm-logo-subtitle">&amp; Robotics</span></div></a></div><div class="nm-navbar-links"><a class="nm-nav-link" href="/ai-native-textbook-docusaurus/">Home</a><a class="nm-nav-link" href="/ai-native-textbook-docusaurus/chapters">Chapters</a><a class="nm-nav-link" href="/ai-native-textbook-docusaurus/docs/intro">Documentation</a><a class="nm-nav-link" href="/ai-native-textbook-docusaurus/about">About</a></div><div class="nm-navbar-actions"><div class="nm-search-container" style="margin-right:1rem"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div><button class="nm-action-button color-mode-toggle" aria-label="Toggle dark mode"><svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg></button><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus" class="nm-action-button" aria-label="GitHub" target="_blank" rel="noopener noreferrer"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a><button class="nm-mobile-menu-toggle" aria-label="Toggle mobile menu"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-menu w-6 h-6" aria-hidden="true"><path d="M4 5h16"></path><path d="M4 12h16"></path><path d="M4 19h16"></path></svg></button></div></div></nav><nav aria-label="Main" class="theme-layout-navbar navbar navbar--fixed-top"><div class="navbar__inner"><div class="theme-layout-navbar-left navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ai-native-textbook-docusaurus/"><b class="navbar__title text--truncate">Physical AI &amp; Robotics</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/ai-native-textbook-docusaurus/">Home</a><a class="navbar__item navbar__link" href="/ai-native-textbook-docusaurus/chapters">Chapters</a><a class="navbar__item navbar__link" href="/ai-native-textbook-docusaurus/docs/intro">Documentation</a></div><div class="theme-layout-navbar-right navbar__items navbar__items--right"><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-label="(opens in new tab)" class="iconExternalLink_nPIU"><use href="#theme-svg-external-link"></use></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="system mode" aria-label="Switch between dark and light mode (currently system mode)"><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" aria-hidden="true" class="toggleIcon_g3eP systemToggleIcon_QzmC"><path fill="currentColor" d="m12 21c4.971 0 9-4.029 9-9s-4.029-9-9-9-9 4.029-9 9 4.029 9 9 9zm4.95-13.95c1.313 1.313 2.05 3.093 2.05 4.95s-0.738 3.637-2.05 4.95c-1.313 1.313-3.093 2.05-4.95 2.05v-14c1.857 0 3.637 0.737 4.95 2.05z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input searchInput_YFbd" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="theme-layout-main main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/ai-native-textbook-docusaurus/docs/part-1-foundations/chapter-1-what-is-physical-ai"><span title="Part 1: Foundations" class="categoryLinkLabel_W154">Part 1: Foundations</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-4-ros2-fundamentals"><span title="Part 2: ROS Fundamentals" class="categoryLinkLabel_W154">Part 2: ROS Fundamentals</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/ai-native-textbook-docusaurus/docs/part-3-simulation/chapter-7-gazebo-physics-simulation"><span title="Part 3: Simulation &amp; Digital Twins" class="categoryLinkLabel_W154">Part 3: Simulation &amp; Digital Twins</span></a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret menu__link--active" role="button" aria-expanded="true" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-13-computer-vision-robots"><span title="Part 4: Perception &amp; State Estimation" class="categoryLinkLabel_W154">Part 4: Perception &amp; State Estimation</span></a></div><ul class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-13-computer-vision-robots"><span title="Computer Vision for Robots" class="linkLabel_WmDU">Computer Vision for Robots</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-14-sensor-fusion-state-estimation"><span title="Sensor Fusion and State Estimation" class="linkLabel_WmDU">Sensor Fusion and State Estimation</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-15-slam-vslam-navigation"><span title="SLAM, VSLAM, and Navigation" class="linkLabel_WmDU">SLAM, VSLAM, and Navigation</span></a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms"><span title="Path Planning Algorithms" class="linkLabel_WmDU">Path Planning Algorithms</span></a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="categoryLink_byQd menu__link menu__link--sublist menu__link--sublist-caret" role="button" aria-expanded="false" href="/ai-native-textbook-docusaurus/docs/part-5-embodied-intelligence/chapter-17-vision-language-action-models"><span title="Part 5: Embodied Intelligence" class="categoryLinkLabel_W154">Part 5: Embodied Intelligence</span></a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs"><li class="breadcrumbs__item"><a aria-label="Home page" class="breadcrumbs__link" href="/ai-native-textbook-docusaurus/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li class="breadcrumbs__item"><span class="breadcrumbs__link">Part 4: Perception &amp; State Estimation</span></li><li class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link">Path Planning Algorithms</span></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1 id="chapter-16-path-planning-algorithms">Chapter 16: Path Planning Algorithms</h1></header>
<h2 id="161-path-planning-fundamentals">16.1 Path Planning Fundamentals</h2>
<h3 id="1611-the-path-planning-problem">16.1.1 The Path Planning Problem</h3>
<p>Path planning finds a collision-free path from start to goal in a configuration space while optimizing criteria like shortest distance, smoothness, or execution time.</p>
<admonition type="info"><p>Path planning differs from navigation in that it computes the geometric path, while navigation includes real-time control to follow the path. Good path planning considers both global optimality and local execution feasibility.</p></admonition>
<h3 id="1612-configuration-space">16.1.2 Configuration Space</h3>
<p>Configuration space (C-space) represents all possible robot configurations:</p>
<pre><code class="language-python">class ConfigurationSpace:
    def __init__(self, robot_dimensions, workspace_bounds):
        self.robot_width = robot_dimensions[&#x27;width&#x27;]
        self.robot_height = robot_dimensions[&#x27;height&#x27;]
        self.workspace_bounds = workspace_bounds  # [xmin, ymin, xmax, ymax]

        # Configuration space resolution
        self.resolution = 0.05  # 5cm grid

        # Grid dimensions
        self.width = int((workspace_bounds[2] - workspace_bounds[0]) / self.resolution)
        self.height = int((workspace_bounds[3] - workspace_bounds[1]) / self.resolution)

        # Occupancy grid
        self.occupancy_grid = np.zeros((self.width, self.height), dtype=np.uint8)
        self.obstacles = []

    def add_obstacle(self, obstacle):
        &quot;&quot;&quot;Add obstacle to configuration space&quot;&quot;&quot;
        self.obstacles.append(obstacle)
        self._update_occupancy_grid(obstacle)

    def _update_occupancy_grid(self, obstacle):
        &quot;&quot;&quot;Update occupancy grid for Minkowski sum with robot footprint&quot;&quot;&quot;
        # Get obstacle pixels
        obstacle_pixels = self._world_to_grid(obstacle.get_pixels())

        # Expand for robot footprint (Minkowski sum)
        robot_radius_pixels = int(max(self.robot_width, self.robot_height) / (2 * self.resolution))

        for pixel in obstacle_pixels:
            x, y = pixel
            # Draw filled circle for robot footprint
            for dx in range(-robot_radius_pixels, robot_radius_pixels + 1):
                for dy in range(-robot_radius_pixels, robot_radius_pixels + 1):
                    if dx*dx + dy*dy &lt;= robot_radius_pixels*robot_radius_pixels:
                        nx, ny = x + dx, y + dy
                        if 0 &lt;= nx &lt; self.width and 0 &lt;= ny &lt; self.height:
                            self.occupancy_grid[nx, ny] = 1

    def world_to_grid(self, world_point):
        &quot;&quot;&quot;Convert world coordinates to grid coordinates&quot;&quot;&quot;
        x = int((world_point[0] - self.workspace_bounds[0]) / self.resolution)
        y = int((world_point[1] - self.workspace_bounds[1]) / self.resolution)
        return x, y

    def grid_to_world(self, grid_point):
        &quot;&quot;&quot;Convert grid coordinates to world coordinates&quot;&quot;&quot;
        x = grid_point[0] * self.resolution + self.workspace_bounds[0]
        y = grid_point[1] * self.resolution + self.workspace_bounds[1]
        return np.array([x, y])

    def is_collision_free(self, position):
        &quot;&quot;&quot;Check if position is collision-free&quot;&quot;&quot;
        grid_point = self.world_to_grid(position)

        if not self._is_valid_grid(grid_point):
            return False

        return self.occupancy_grid[grid_point[0], grid_point[1]] == 0

    def _is_valid_grid(self, grid_point):
        &quot;&quot;&quot;Check if grid point is within bounds&quot;&quot;&quot;
        x, y = grid_point
        return 0 &lt;= x &lt; self.width and 0 &lt;= y &lt; self.height

    def is_path_collision_free(self, path):
        &quot;&quot;&quot;Check if entire path is collision-free&quot;&quot;&quot;
        for position in path:
            if not self.is_collision_free(position):
                return False

        return True
</code></pre>
<h2 id="162-classical-planning-algorithms">16.2 Classical Planning Algorithms</h2>
<h3 id="1621-dijkstras-algorithm">16.2.1 Dijkstra&#x27;s Algorithm</h3>
<p>Dijkstra&#x27;s algorithm finds the shortest path in weighted graphs:</p>
<pre><code class="language-python">class DijkstraPlanner:
    def __init__(self, config_space):
        self.config_space = config_space
        self.grid = config_space.occupancy_grid
        self.width = config_space.width
        self.height = config_space.height

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Plan path using Dijkstra&#x27;s algorithm&quot;&quot;&quot;
        start_grid = self.config_space.world_to_grid(start)
        goal_grid = self.config_space.world_to_grid(goal)

        if not self._is_valid_start_goal(start_grid, goal_grid):
            return None

        # Initialize distances
        distances = np.full((self.width, self.height), np.inf)
        distances[start_grid[0], start_grid[1]] = 0

        # Parent tracking
        parents = np.zeros((self.width, self.height, 2), dtype=int)
        parents[start_grid[0], start_grid[1]] = start_grid

        # Priority queue (min-heap)
        open_set = []
        heapq.heappush(open_set, (0, start_grid))

        # Visited set
        closed_set = set()

        while open_set:
            # Get node with minimum distance
            current_distance, current_grid = heapq.heappop(open_set)

            if current_grid == goal_grid:
                # Goal reached - reconstruct path
                return self._reconstruct_path(parents, start_grid, goal_grid)

            closed_set.add(current_grid)

            # Explore neighbors
            for neighbor in self._get_neighbors(current_grid):
                if neighbor in closed_set:
                    continue

                # Edge cost (uniform for grid)
                edge_cost = 1.0
                new_distance = current_distance + edge_cost

                if new_distance &lt; distances[neighbor[0], neighbor[1]]:
                    distances[neighbor[0], neighbor[1]] = new_distance
                    parents[neighbor[0], neighbor[1]] = current_grid
                    heapq.heappush(open_set, (new_distance, neighbor))

        return None  # No path found

    def _get_neighbors(self, grid_point):
        &quot;&quot;&quot;Get valid neighboring grid cells&quot;&quot;&quot;
        neighbors = []
        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 4-connected

        for dx, dy in directions:
            neighbor = (grid_point[0] + dx, grid_point[1] + dy)
            if self._is_valid_neighbor(neighbor):
                neighbors.append(neighbor)

        return neighbors

    def _is_valid_neighbor(self, grid_point):
        &quot;&quot;&quot;Check if neighbor is valid and collision-free&quot;&quot;&quot;
        x, y = grid_point
        return (0 &lt;= x &lt; self.width and
                0 &lt;= y &lt; self.height and
                self.grid[x, y] == 0)

    def _is_valid_start_goal(self, start_grid, goal_grid):
        &quot;&quot;&quot;Validate start and goal positions&quot;&quot;&quot;
        return (self._is_valid_neighbor(start_grid) and
                self._is_valid_neighbor(goal_grid))

    def _reconstruct_path(self, parents, start_grid, goal_grid):
        &quot;&quot;&quot;Reconstruct path from parent pointers&quot;&quot;&quot;
        path = [goal_grid]
        current = goal_grid

        while not np.array_equal(current, start_grid):
            current = tuple(parents[current[0], current[1]])
            path.append(current)

        path.reverse()

        # Convert to world coordinates
        world_path = [self.config_space.grid_to_world(grid) for grid in path]
        return world_path
</code></pre>
<h3 id="1622-a-algorithm">16.2.2 A* Algorithm</h3>
<p>A* algorithm uses heuristics to guide search more efficiently:</p>
<pre><code class="language-python">class AStarPlanner:
    def __init__(self, config_space, heuristic_weight=1.0):
        self.config_space = config_space
        self.grid = config_space.occupancy_grid
        self.width = config_space.width
        self.height = config_space.height
        self.heuristic_weight = heuristic_weight

        # Precompute heuristic
        self._precompute_heuristic()

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Plan path using A* algorithm&quot;&quot;&quot;
        start_grid = self.config_space.world_to_grid(start)
        goal_grid = self.config_space.world_to_grid(goal)

        if not self._is_valid_start_goal(start_grid, goal_grid):
            return None

        # Node structure: (f_cost, g_cost, grid_point, parent)
        open_set = []
        start_h = self._heuristic(start_grid, goal_grid)
        heapq.heappush(open_set, (start_h, 0, start_grid, None))

        # Distance to goal
        distances = np.full((self.width, self.height), np.inf)
        distances[start_grid[0], start_grid[1]] = 0

        # Closed set
        closed_set = set()

        while open_set:
            # Get node with minimum f_cost
            f_cost, g_cost, current_grid, parent = heapq.heappop(open_set)

            if current_grid == goal_grid:
                # Goal reached - reconstruct path
                return self._reconstruct_path(parent, start_grid, goal_grid)

            closed_set.add(current_grid)

            # Explore neighbors
            for neighbor in self._get_neighbors(current_grid):
                if neighbor in closed_set:
                    continue

                # Movement cost
                edge_cost = self._edge_cost(current_grid, neighbor)
                tentative_g_cost = g_cost + edge_cost

                if tentative_g_cost &lt; distances[neighbor[0], neighbor[1]]:
                    distances[neighbor[0], neighbor[1]] = tentative_g_cost

                    h_cost = self._heuristic(neighbor, goal_grid)
                    f_cost = tentative_g_cost + self.heuristic_weight * h_cost

                    heapq.heappush(open_set, (f_cost, tentative_g_cost, neighbor, current_grid))

        return None  # No path found

    def _heuristic(self, grid1, grid2):
        &quot;&quot;&quot;A* heuristic (Euclidean distance)&quot;&quot;&quot;
        # Use precomputed values for speed
        return self.precomputed_heuristic[grid1[0], grid1[1], grid2[0], grid2[1]]

    def _precompute_heuristic(self):
        &quot;&quot;&quot;Precompute heuristic values for all grid pairs&quot;&quot;&quot;
        self.precomputed_heuristic = np.zeros((self.width, self.height, self.width, self.height))

        for x1 in range(self.width):
            for y1 in range(self.height):
                for x2 in range(self.width):
                    for y2 in range(self.height):
                        dx = abs(x2 - x1)
                        dy = abs(y2 - y1)
                        self.precomputed_heuristic[x1, y1, x2, y2] = np.sqrt(dx*dx + dy*dy)

    def _edge_cost(self, from_grid, to_grid):
        &quot;&quot;&quot;Calculate edge cost between grid cells&quot;&quot;&quot;
        dx = abs(to_grid[0] - from_grid[0])
        dy = abs(to_grid[1] - from_grid[1])

        if dx == 1 and dy == 1:
            return 1.414  # Diagonal movement
        else:
            return 1.0  # Cardinal movement

class ThetaStarPlanner:
    def __init__(self, config_space):
        self.config_space = config_space
        self.grid = config_space.occupancy_grid
        self.width = config_space.width
        self.height = config_space.height

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Plan path considering robot orientation&quot;&quot;&quot;
        start_grid = self.config_space.world_to_grid(start)
        start_theta = int(start[2] * 180 / np.pi) % 360
        goal_grid = self.config_space.world_to_grid(goal)
        goal_theta = int(goal[2] * 180 / np.pi) % 360

        # 3D state space: (x, y, theta)
        start_state = (start_grid[0], start_grid[1], start_theta)
        goal_state = (goal_grid[0], goal_grid[1], goal_theta)

        # Priority queue: (f_cost, g_cost, state, parent)
        open_set = []
        start_h = self._heuristic_3d(start_state, goal_state)
        heapq.heappush(open_set, (start_h, 0, start_state, None))

        # Visited states
        visited = set()
        visited.add(start_state)

        # Parent tracking
        parents = {}

        while open_set:
            f_cost, g_cost, current_state, parent = heapq.heappop(open_set)

            if self._is_goal(current_state, goal_state):
                return self._reconstruct_path_3d(parents, start_state, goal_state)

            # Generate successor states
            successors = self._get_successors_3d(current_state)

            for successor_state, action_cost in successors:
                if successor_state not in visited:
                    visited.add(successor_state)

                    tentative_g_cost = g_cost + action_cost
                    h_cost = self._heuristic_3d(successor_state, goal_state)
                    f_cost = tentative_g_cost + h_cost

                    heapq.heappush(open_set, (f_cost, tentative_g_cost, successor_state, current_state))
                    parents[successor_state] = current_state

        return None

    def _get_successors_3d(self, state):
        &quot;&quot;&quot;Get successor states in 3D configuration space&quot;&quot;&quot;
        successors = []
        x, y, theta = state

        # Position movements (4-connected)
        movements = [(1, 0), (0, 1), (-1, 0), (0, -1)]

        for dx, dy in movements:
            new_x, new_y = x + dx, y + dy
            new_theta = theta

            if self._is_valid_position(new_x, new_y):
                successors.append(((new_x, new_y, new_theta), 1.0))

        # Orientation changes (45-degree steps)
        angle_steps = [45, -45]
        for dtheta in angle_steps:
            new_theta = (theta + dtheta) % 360
            successors.append(((x, y, new_theta), 0.5))

        return successors

    def _heuristic_3d(self, state1, state2):
        &quot;&quot;&quot;3D heuristic combining position and orientation&quot;&quot;&quot;
        x1, y1, theta1 = state1
        x2, y2, theta2 = state2

        # Position heuristic
        dx = abs(x2 - x1)
        dy = abs(y2 - y1)
        position_cost = np.sqrt(dx*dx + dy*dy)

        # Orientation heuristic (normalized to [0, 1])
        theta_diff = abs(theta2 - theta1)
        theta_diff = min(theta_diff, 360 - theta_diff)
        orientation_cost = theta_diff / 360.0

        # Weighted combination
        return position_cost + 0.1 * orientation_cost
</code></pre>
<h2 id="163-sampling-based-planners">16.3 Sampling-Based Planners</h2>
<h3 id="1631-probabilistic-roadmaps-prm">16.3.1 Probabilistic Roadmaps (PRM)</h3>
<p>PRM builds a roadmap of collision-free paths:</p>
<pre><code class="language-python">class ProbabilisticRoadmap:
    def __init__(self, config_space, num_samples=1000, connection_radius=2.0):
        self.config_space = config_space
        self.num_samples = num_samples
        self.connection_radius = connection_radius

        # Roadmap structure
        self.nodes = []  # List of (x, y) positions
        self.edges = []  # List of (node1, node2, distance) edges

    def build_roadmap(self):
        &quot;&quot;&quot;Build probabilistic roadmap&quot;&quot;&quot;
        print(&quot;Building PRM roadmap...&quot;)

        # Step 1: Generate random collision-free samples
        self._generate_samples()

        # Step 2: Connect nearby samples
        self._connect_samples()

        print(f&quot;Roadmap built with {len(self.nodes)} nodes and {len(self.edges)} edges&quot;)

    def _generate_samples(self):
        &quot;&quot;&quot;Generate random collision-free samples&quot;&quot;&quot;
        samples_generated = 0
        attempts = 0
        max_attempts = self.num_samples * 10

        while samples_generated &lt; self.num_samples and attempts &lt; max_attempts:
            # Generate random sample
            x = np.random.uniform(self.config_space.workspace_bounds[0],
                               self.config_space.workspace_bounds[2])
            y = np.random.uniform(self.config_space.workspace_bounds[1],
                               self.config_space.workspace_bounds[3])

            # Check if collision-free
            if self.config_space.is_collision_free((x, y)):
                self.nodes.append((x, y))
                samples_generated += 1

            attempts += 1

    def _connect_samples(self):
        &quot;&quot;&quot;Connect nearby samples in roadmap&quot;&quot;&quot;
        for i in range(len(self.nodes)):
            for j in range(i + 1, len(self.nodes)):
                # Calculate Euclidean distance
                distance = np.linalg.norm(np.array(self.nodes[i]) - np.array(self.nodes[j]))

                if distance &lt;= self.connection_radius:
                    # Check if connection is collision-free
                    if self._is_path_collision_free(self.nodes[i], self.nodes[j]):
                        self.edges.append((i, j, distance))
                        self.edges.append((j, i, distance))

    def _is_path_collision_free(self, point1, point2):
        &quot;&quot;&quot;Check if straight-line path between points is collision-free&quot;&quot;&quot;
        # Sample points along the line
        num_samples = int(np.linalg.norm(np.array(point2) - np.array(point1)) / 0.05)

        if num_samples &lt; 2:
            return self.config_space.is_collision_free(point1) and \
                   self.config_space.is_collision_free(point2)

        for t in np.linspace(0, 1, num_samples):
            point = point1 + t * (np.array(point2) - np.array(point1))
            if not self.config_space.is_collision_free(point):
                return False

        return True

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Find path using built roadmap&quot;&quot;&quot;
        start_idx = self._find_nearest_node(start)
        goal_idx = self._find_nearest_node(goal)

        if start_idx is None or goal_idx is None:
            return None

        # Connect start and goal to roadmap
        connected_edges = self._connect_to_roadmap(start, start_idx, goal, goal_idx)

        if not connected_edges:
            return None

        # Find path using Dijkstra on roadmap graph
        path_indices = self._find_path_in_graph(start_idx, goal_idx)

        if path_indices is None:
            return None

        # Convert indices to positions
        path = [self.nodes[idx] for idx in path_indices]

        return path

    def _find_nearest_node(self, point):
        &quot;&quot;&quot;Find nearest node in roadmap&quot;&quot;&quot;
        min_distance = float(&#x27;inf&#x27;)
        nearest_idx = None

        for i, node in enumerate(self.nodes):
            distance = np.linalg.norm(np.array(node) - np.array(point))
            if distance &lt; min_distance:
                min_distance = distance
                nearest_idx = i

        return nearest_idx if min_distance &lt; self.connection_radius else None

    def _connect_to_roadmap(self, start, start_idx, goal, goal_idx):
        &quot;&quot;&quot;Connect start and goal points to roadmap&quot;&quot;&quot;
        # Connect start to nearest node
        if start_idx is not None:
            if self.config_space.is_path_collision_free(start, self.nodes[start_idx]):
                self.nodes.append(start)
                new_start_idx = len(self.nodes) - 1
                self.edges.append((new_start_idx, start_idx,
                                np.linalg.norm(np.array(start) - np.array(self.nodes[start_idx]))))
            else:
                return False

        # Connect goal to nearest node
        if goal_idx is not None:
            if self.config_space.is_path_collision_free(goal, self.nodes[goal_idx]):
                self.nodes.append(goal)
                new_goal_idx = len(self.nodes) - 1
                self.edges.append((goal_idx, new_goal_idx,
                                np.linalg.norm(np.array(goal) - np.array(self.nodes[goal_idx]))))
            else:
                return False

        return True

    def _find_path_in_graph(self, start_idx, goal_idx):
        &quot;&quot;&quot;Find shortest path in graph using Dijkstra&quot;&quot;&quot;
        num_nodes = len(self.nodes)
        if num_nodes == 0:
            return None

        # Build adjacency list
        adjacency = [[] for _ in range(num_nodes)]
        for edge in self.edges:
            adjacency[edge[0]].append((edge[1], edge[2]))
            adjacency[edge[1]].append((edge[0], edge[2]))

        # Dijkstra&#x27;s algorithm
        distances = np.full(num_nodes, np.inf)
        distances[start_idx] = 0

        parents = np.full(num_nodes, -1)
        visited = [False] * num_nodes

        pq = [(0, start_idx)]

        while pq:
            dist, current = heapq.heappop(pq)

            if visited[current]:
                continue

            visited[current] = True

            if current == goal_idx:
                # Reconstruct path
                path = []
                node = current
                while node != -1:
                    path.append(node)
                    node = parents[node]
                return path[::-1]

            for neighbor, edge_dist in adjacency[current]:
                new_dist = dist + edge_dist
                if new_dist &lt; distances[neighbor]:
                    distances[neighbor] = new_dist
                    parents[neighbor] = current
                    heapq.heappush(pq, (new_dist, neighbor))

        return None  # No path found
</code></pre>
<h3 id="1632-rapidly-exploring-random-trees-rrt">16.3.2 Rapidly-exploring Random Trees (RRT)</h3>
<p>RRT rapidly explores configuration space with random sampling:</p>
<pre><code class="language-python">class RRTPlanner:
    def __init__(self, config_space, max_iterations=5000, step_size=0.5):
        self.config_space = config_space
        self.max_iterations = max_iterations
        self.step_size = step_size

        # Tree structure
        self.tree = []
        self.parent = []

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Plan path using RRT&quot;&quot;&quot;
        # Initialize tree with start point
        self.tree = [start]
        self.parent = [-1]

        goal_tolerance = self.step_size

        for iteration in range(self.max_iterations):
            # Sample random point
            if np.random.random() &lt; 0.1:  # 10% chance to sample goal
                random_point = goal
            else:
                random_point = self._sample_random_point()

            # Find nearest node in tree
            nearest_idx = self._find_nearest_node(random_point)
            nearest_node = self.tree[nearest_idx]

            # Extend tree towards random point
            new_node = self._extend_towards(nearest_node, random_point)

            # Check if extension is valid
            if self.config_space.is_collision_free(new_node):
                # Add to tree
                self.tree.append(new_node)
                self.parent.append(nearest_idx)

                # Check if goal reached
                if np.linalg.norm(np.array(new_node) - np.array(goal)) &lt; goal_tolerance:
                    return self._reconstruct_path_to_root(len(self.tree) - 1)

        return None  # No path found

    def _sample_random_point(self):
        &quot;&quot;&quot;Sample random point in configuration space&quot;&quot;&quot;
        x = np.random.uniform(self.config_space.workspace_bounds[0],
                               self.config_space.workspace_bounds[2])
        y = np.random.uniform(self.config_space.workspace_bounds[1],
                               self.config_space.workspace_bounds[3])
        return np.array([x, y])

    def _find_nearest_node(self, point):
        &quot;&quot;&quot;Find nearest node in tree&quot;&quot;&quot;
        min_distance = float(&#x27;inf)
        nearest_idx = 0

        for i, node in enumerate(self.tree):
            distance = np.linalg.norm(np.array(node) - np.array(point))
            if distance &lt; min_distance:
                min_distance = distance
                nearest_idx = i

        return nearest_idx

    def _extend_towards(self, from_node, to_point):
        &quot;&quot;&quot;Extend tree from node towards point&quot;&quot;&quot;
        direction = np.array(to_point) - np.array(from_node)
        distance = np.linalg.norm(direction)

        if distance &lt;= self.step_size:
            return to_point
        else:
            # Normalize and step
            direction = direction / distance
            return np.array(from_node) + direction * self.step_size

    def _reconstruct_path_to_root(self, node_idx):
        &quot;&quot;&quot;Reconstruct path from node to root&quot;&quot;&quot;
        path = []
        current = node_idx

        while current != -1:
            path.append(self.tree[current])
            current = self.parent[current]

        return path[::-1]

class RRTStarPlanner(RRTPlanner):
    def __init__(self, config_space, max_iterations=5000, step_size=0.5, rewire_radius=1.0):
        super().__init__(config_space, max_iterations, step_size)
        self.rewire_radius = rewire_radius

    def plan_path(self, start, goal):
        &quot;&quot;&quot;Plan path using RRT* with rewiring&quot;&quot;&quot;
        # Initialize tree with start point
        self.tree = [start]
        self.parent = [-1]

        # Track costs
        self.costs = [0.0]

        goal_tolerance = self.step_size

        for iteration in range(self.max_iterations):
            # Sample random point
            if np.random.random() &lt; 0.1:
                random_point = goal
            else:
                random_point = self._sample_random_point()

            # Find nearest node
            nearest_idx = self._find_nearest_node(random_point)
            nearest_node = self.tree[nearest_idx]
            nearest_cost = self.costs[nearest_idx]

            # Extend tree
            new_node = self._extend_towards(nearest_node, random_point)
            new_idx = len(self.tree)

            if self.config_space.is_collision_free(new_node):
                # Calculate cost
                edge_cost = np.linalg.norm(np.array(new_node) - np.array(nearest_node))
                new_cost = nearest_cost + edge_cost

                # Add to tree
                self.tree.append(new_node)
                self.parent.append(nearest_idx)
                self.costs.append(new_cost)

                # Check if goal reached
                if np.linalg.norm(np.array(new_node) - np.array(goal)) &lt; goal_tolerance:
                    return self._reconstruct_path_to_root(new_idx)

                # Rewiring step
                self._rewire_tree(new_idx)

        return None

    def _rewire_tree(self, new_node_idx):
        &quot;&quot;&quot;Rewire tree for optimal cost paths&quot;&quot;&quot;
        new_node = self.tree[new_node_idx]

        # Find nodes within rewire radius
        for i, node in enumerate(self.tree):
            if i == new_node_idx:
                continue

            distance = np.linalg.norm(np.array(node) - np.array(new_node))

            if distance &lt; self.rewire_radius:
                # Calculate new cost through this node
                edge_cost = distance
                new_cost = self.costs[i] + edge_cost

                # Rewire if better path
                if new_cost &lt; self.costs[new_node_idx]:
                    self.parent[new_node_idx] = i
                    self.costs[new_node_idx] = new_cost

                    # Update costs of children
                    self._update_children_costs(new_node_idx)

    def _update_children_costs(self, parent_idx):
        &quot;&quot;&quot;Update costs of children after rewiring&quot;&quot;&quot;
        parent_cost = self.costs[parent_idx]

        for i, parent in enumerate(self.parent):
            if parent == parent_idx:
                edge_cost = np.linalg.norm(
                    np.array(self.tree[i]) - np.array(self.tree[parent_idx])
                )
                self.costs[i] = parent_cost + edge_cost
                self._update_children_costs(i)
</code></pre>
<h2 id="164-optimization-based-planning">16.4 Optimization-Based Planning</h2>
<h3 id="1641-trajectory-optimization">16.4.1 Trajectory Optimization</h3>
<p>Optimize smooth trajectories for robot execution:</p>
<pre><code class="language-python">class TrajectoryOptimizer:
    def __init__(self, config_space):
        self.config_space = config_space
        self.dt = 0.1  # Time step
        self.max_velocity = 2.0
        self.max_acceleration = 1.0

    def optimize_trajectory(self, path, initial_guess=None):
        &quot;&quot;&quot;Optimize smooth trajectory from waypoints&quot;&quot;&quot;
        if len(path) &lt; 2:
            return path

        # Create initial trajectory guess
        if initial_guess is None:
            trajectory = self._create_initial_trajectory(path)
        else:
            trajectory = initial_guess.copy()

        # Optimization parameters
        iterations = 100
        learning_rate = 0.1

        for iteration in range(iterations):
            # Compute gradient
            gradient = self._compute_gradient(trajectory, path)

            # Update trajectory
            trajectory = trajectory - learning_rate * gradient

            # Apply constraints
            trajectory = self._apply_constraints(trajectory)

            # Check for collisions
            if self._is_trajectory_collision_free(trajectory):
                break

        return trajectory

    def _create_initial_trajectory(self, path):
        &quot;&quot;&quot;Create initial trajectory from waypoints&quot;&quot;&quot;
        trajectory = []

        for i in range(len(path) - 1):
            start = path[i]
            end = path[i + 1]

            # Number of intermediate points
            distance = np.linalg.norm(end - start)
            num_points = max(2, int(distance / (self.max_velocity * self.dt)))

            for t in np.linspace(0, 1, num_points):
                # Linear interpolation
                point = start + t * (end - start)
                trajectory.append(point)

        return np.array(trajectory)

    def _compute_gradient(self, trajectory, path):
        &quot;&quot;&quot;Compute gradient of cost function&quot;&quot;&quot;
        n_points = len(trajectory)
        gradient = np.zeros_like(trajectory)

        # Smoothness gradient
        for i in range(1, n_points - 1):
            # Second derivative
            d2p = trajectory[i+1] - 2 * trajectory[i] + trajectory[i-1]

            # Weight for smoothness
            weight = 1.0
            gradient[i] += 2 * weight * d2p

        # Waypoint attraction gradient
        waypoint_attraction_weight = 2.0

        for i, point in enumerate(trajectory):
            # Find nearest waypoint
            min_dist = float(&#x27;inf)
            nearest_waypoint = None
            waypoint_idx = 0

            for j, waypoint in enumerate(path):
                dist = np.linalg.norm(point - waypoint)
                if dist &lt; min_dist:
                    min_dist = dist
                    nearest_waypoint = waypoint
                    waypoint_idx = j

            if min_dist &gt; 0:
                # Attract towards waypoint
                direction = nearest_waypoint - point
                gradient[i] += waypoint_attraction_weight * direction

        return gradient

    def _apply_constraints(self, trajectory):
        &quot;&quot;&quot;Apply velocity and acceleration constraints&quot;&quot;&quot;
        n_points = len(trajectory)

        for i in range(n_points):
            # Velocity constraint
            if i &gt; 0:
                velocity = (trajectory[i] - trajectory[i-1]) / self.dt
                velocity_norm = np.linalg.norm(velocity)

                if velocity_norm &gt; self.max_velocity:
                    velocity = velocity / velocity_norm * self.max_velocity
                    trajectory[i] = trajectory[i-1] + velocity * self.dt

            # Acceleration constraint
            if i &gt; 1:
                acceleration = (trajectory[i] - 2*trajectory[i-1] + trajectory[i-2]) / (self.dt**2)
                acc_norm = np.linalg.norm(acceleration)

                if acc_norm &gt; self.max_acceleration:
                    acceleration = acceleration / acc_norm * self.max_acceleration
                    trajectory[i] = 2*trajectory[i-1] - trajectory[i-2] + acceleration * (self.dt**2)

        return trajectory

    def _is_trajectory_collision_free(self, trajectory):
        &quot;&quot;&quot;Check if entire trajectory is collision-free&quot;&quot;&quot;
        for point in trajectory:
            if not self.config_space.is_collision_free(point):
                return False
        return True

class CHOMPPlanner:
    def __init__(self, config_space):
        self.config_space = config_space
        self.max_iterations = 100
        self.tolerance = 0.1

    def plan_with_chomp(self, start, goal):
        &quot;&quot;&quot;Plan path using CHOMP optimization&quot;&quot;&quot;
        # Initial guess - straight line path
        initial_path = self._straight_line_path(start, goal)

        if not self.config_space.is_path_collision_free(initial_path):
            # Try to find collision-free initial path
            initial_path = self._find_initial_path(start, goal)

        if initial_path is None:
            return None

        # Optimize path using CHOMP
        optimized_path = self._optimize_path_chomp(initial_path, start, goal)

        return optimized_path

    def _optimize_path_chomp(self, path, start, goal):
        &quot;&quot;&quot;Optimize path using CHOMP algorithm&quot;&quot;&quot;
        current_path = path.copy()

        for iteration in range(self.max_iterations):
            # Compute gradient
            gradient = self._chomp_gradient(current_path, start, goal)

            # Update path
            current_path = current_path - 0.1 * gradient

            # Check collision constraints
            max_violation = self._check_collision_constraints(current_path)

            if max_violation &lt; self.tolerance:
                break

            # Project back into collision-free space
            current_path = self._project_collision_free(current_path, max_violation)

        return current_path

    def _chomp_gradient(self, path, start, goal):
        &quot;&quot;&quot;Compute CHOMP gradient&quot;&quot;&quot;
        n_points = len(path)
        gradient = np.zeros_like(path)

        # Obstacle gradient
        for i, point in enumerate(path):
            # Find nearest obstacle
            nearest_obstacle, distance = self._find_nearest_obstacle(point)

            if distance &gt; 0:
                # Gradient away from obstacle
                direction = point - nearest_obstacle
                norm = np.linalg.norm(direction)

                if norm &gt; 0:
                    # Use potential field gradient
                    influence_radius = 2.0
                    if distance &lt; influence_radius:
                        gradient_magnitude = (1/distance - 1/influence_radius)
                        gradient[i] += gradient_magnitude * direction / norm

        # Smoothness gradient
        for i in range(1, n_points - 1):
            d2p = path[i+1] - 2 * path[i] + path[i-1]
            gradient[i] += 2 * d2p

        # Goal attraction gradient
        for i in range(n_points):
            # Progress towards goal along path
            if i &lt; n_points - 1:
                remaining = path[-1] - path[i]
                progress = (i + 1) / n_points
                desired = path[i] + progress * remaining
                gradient[i] += 2 * (desired - path[i])

        # Start point constraint
        gradient[0] += 10 * (start - path[0])

        return gradient

    def _find_nearest_obstacle(self, point):
        &quot;&quot;&quot;Find nearest obstacle point&quot;&quot;&quot;
        min_distance = float(&#x27;inf)
        nearest_point = point.copy()

        # Check grid cells in neighborhood
        grid_x, grid_y = self.config_space.world_to_grid(point)
        search_radius = 5

        for dx in range(-search_radius, search_radius + 1):
            for dy in range(-search_radius, search_radius + 1):
                check_x, check_y = grid_x + dx, grid_y + dy

                if (0 &lt;= check_x &lt; self.config_space.width and
                    0 &lt;= check_y &lt; self.config_space.height and
                    self.config_space.occupancy_grid[check_x, check_y] &gt; 0):

                    obstacle_point = self.config_space.grid_to_world((check_x, check_y))
                    distance = np.linalg.norm(point - obstacle_point)

                    if distance &lt; min_distance:
                        min_distance = distance
                        nearest_point = obstacle_point.copy()

        return nearest_point, min_distance
</code></pre>
<h2 id="chapter-summary">Chapter Summary</h2>
<p>This chapter covered comprehensive path planning algorithms for robotics:</p>
<h3 id="key-concepts-covered">Key Concepts Covered</h3>
<ol>
<li><strong>Configuration Space</strong>: Mathematical representation of robot configurations</li>
<li><strong>Classical Planners</strong>: Dijkstra&#x27;s algorithm and A* with heuristics</li>
<li><strong>Sampling-Based Planners</strong>: PRM and RRT/RRT* for high-dimensional spaces</li>
<li><strong>Optimization-Based Planning</strong>: CHOMP and trajectory optimization</li>
<li><strong>Path Execution</strong>: Control laws and trajectory following</li>
<li><strong>Practical Considerations</strong>: Computational efficiency and real-time constraints</li>
</ol>
<h3 id="practical-implementations">Practical Implementations</h3>
<ul>
<li>Complete configuration space representation with Minkowski sum</li>
<li>A* planner with precomputed heuristics and Theta* variant</li>
<li>PRM with probabilistic sampling and connection strategies</li>
<li>RRT and RRT* with rewiring for optimal paths</li>
<li>Trajectory optimization with smoothness and dynamics constraints</li>
<li>CHOMP optimization with obstacle avoidance using potential fields</li>
</ul>
<h3 id="next-steps">Next Steps</h3>
<p>With path planning expertise, you&#x27;re ready for:</p>
<ul>
<li>Part V: Embodied Intelligence &amp; VLA (Chapters 17-20)</li>
<li>Vision-Language-Action models</li>
<li>Cognitive planning and decision making</li>
</ul>
<hr>
<h2 id="glossary-terms">Glossary Terms</h2>
<p><strong>Term</strong>: <strong>Configuration Space</strong>
<strong>Definition:</strong> Set of all possible robot configurations, including position, orientation, and joint angles
<strong>Related:</strong> <strong>Degrees of Freedom</strong>, <strong>Configuration Obstacles</strong></p>
<p><strong>Term</strong>: <strong>Minkowski Sum</strong>
<strong>Definition:</strong> Mathematical operation that computes the configuration space obstacle by expanding obstacles by robot shape
<strong>Related:</strong> <strong>Configuration Space</strong>, <strong>Collision Detection</strong></p>
<p><strong>Term</strong>: <strong>Heuristic Function</strong>
<strong>Definition:</strong> Admissible estimate of cost from current state to goal in A* algorithm
<strong>Related:</strong> <strong>Admissibility</strong>, <strong>Consistency</strong></p>
<p><strong>Term</strong>: <strong>Rapidly-exploring Random Tree (RRT)</strong>
<strong>Definition:</strong> Sampling-based planning algorithm that explores configuration space using random sampling and tree growth
<strong>Related:</strong> <strong>Probabilistic Roadmap</strong>, <strong>RRT</strong>*</p>
<p><strong>Term</strong>: <strong>Potential Field</strong>
<strong>Definition:</strong> Gradient-based navigation method where obstacles exert repulsive forces and goal attracts robot
<strong>Related:</strong> <strong>Artificial Potential Fields</strong>, <strong>Navigation Functions</strong></p>
<hr>
<h2 id="exercises">Exercises</h2>
<h3 id="exercise-161-a-implementation">Exercise 16.1: A* Implementation</h3>
<p>Implement complete A* path planner:</p>
<ul>
<li>Create configurable heuristic functions</li>
<li>Add diagonal movements with appropriate costs</li>
<li>Implement path smoothing</li>
<li>Compare performance with different heuristics</li>
</ul>
<h3 id="exercise-162-rrt-planning">Exercise 16.2: RRT* Planning</h3>
<p>Build RRT* planner with rewiring:</p>
<ul>
<li>Implement efficient nearest neighbor search</li>
<li>Add dynamic rewiring for path optimality</li>
<li>Compare with basic RRT performance</li>
<li>Handle dynamic obstacles</li>
</ul>
<h3 id="exercise-83-trajectory-optimization">Exercise 8.3: Trajectory Optimization</h3>
<p>Create trajectory optimization system:</p>
<ul>
<li>Implement CHOMP for path smoothing</li>
<li>Add velocity and acceleration constraints</li>
<li>Optimize for minimum-time trajectories</li>
<li>Visualize optimization process</li>
</ul>
<h3 id="exercise-164-multi-robot-planning">Exercise 16.4: Multi-Robot Planning</h3>
<p>Design multi-robot path planning:</p>
<ul>
<li>Coordinate multiple robot movements</li>
<li>Implement conflict detection and resolution</li>
<li>Add priority-based planning</li>
<li>Simulate multi-robot scenarios</li>
</ul>
<h3 id="exercise-165-dynamic-environment">Exercise 16.5: Dynamic Environment</h3>
<p>Adapt planning for dynamic environments:</p>
<ul>
<li>Implement dynamic obstacle detection</li>
<li>Create re-planning strategies</li>
<li>Handle moving obstacles and goals</li>
<li>Evaluate system responsiveness</li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col noPrint_WFHX"><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus/tree/main/docs/part-4-perception/chapter-16-path-planning-algorithms.mdx" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>Edit this page</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="docusaurus-mt-lg pagination-nav" aria-label="Docs pages"><a class="pagination-nav__link pagination-nav__link--prev" href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-15-slam-vslam-navigation"><div class="pagination-nav__sublabel">Previous</div><div class="pagination-nav__label">SLAM, VSLAM, and Navigation</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/ai-native-textbook-docusaurus/docs/part-5-embodied-intelligence/chapter-17-vision-language-action-models"><div class="pagination-nav__sublabel">Next</div><div class="pagination-nav__label">Chapter 17: Vision-Language-Action Models</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#161-path-planning-fundamentals" class="table-of-contents__link toc-highlight">16.1 Path Planning Fundamentals</a><ul><li><a href="#1611-the-path-planning-problem" class="table-of-contents__link toc-highlight">16.1.1 The Path Planning Problem</a></li><li><a href="#1612-configuration-space" class="table-of-contents__link toc-highlight">16.1.2 Configuration Space</a></li></ul></li><li><a href="#162-classical-planning-algorithms" class="table-of-contents__link toc-highlight">16.2 Classical Planning Algorithms</a><ul><li><a href="#1621-dijkstras-algorithm" class="table-of-contents__link toc-highlight">16.2.1 Dijkstra&#39;s Algorithm</a></li><li><a href="#1622-a-algorithm" class="table-of-contents__link toc-highlight">16.2.2 A* Algorithm</a></li></ul></li><li><a href="#163-sampling-based-planners" class="table-of-contents__link toc-highlight">16.3 Sampling-Based Planners</a><ul><li><a href="#1631-probabilistic-roadmaps-prm" class="table-of-contents__link toc-highlight">16.3.1 Probabilistic Roadmaps (PRM)</a></li><li><a href="#1632-rapidly-exploring-random-trees-rrt" class="table-of-contents__link toc-highlight">16.3.2 Rapidly-exploring Random Trees (RRT)</a></li></ul></li><li><a href="#164-optimization-based-planning" class="table-of-contents__link toc-highlight">16.4 Optimization-Based Planning</a><ul><li><a href="#1641-trajectory-optimization" class="table-of-contents__link toc-highlight">16.4.1 Trajectory Optimization</a></li></ul></li><li><a href="#chapter-summary" class="table-of-contents__link toc-highlight">Chapter Summary</a><ul><li><a href="#key-concepts-covered" class="table-of-contents__link toc-highlight">Key Concepts Covered</a></li><li><a href="#practical-implementations" class="table-of-contents__link toc-highlight">Practical Implementations</a></li><li><a href="#next-steps" class="table-of-contents__link toc-highlight">Next Steps</a></li></ul></li><li><a href="#glossary-terms" class="table-of-contents__link toc-highlight">Glossary Terms</a></li><li><a href="#exercises" class="table-of-contents__link toc-highlight">Exercises</a><ul><li><a href="#exercise-161-a-implementation" class="table-of-contents__link toc-highlight">Exercise 16.1: A* Implementation</a></li><li><a href="#exercise-162-rrt-planning" class="table-of-contents__link toc-highlight">Exercise 16.2: RRT* Planning</a></li><li><a href="#exercise-83-trajectory-optimization" class="table-of-contents__link toc-highlight">Exercise 8.3: Trajectory Optimization</a></li><li><a href="#exercise-164-multi-robot-planning" class="table-of-contents__link toc-highlight">Exercise 16.4: Multi-Robot Planning</a></li><li><a href="#exercise-165-dynamic-environment" class="table-of-contents__link toc-highlight">Exercise 16.5: Dynamic Environment</a></li></ul></li></ul></div></div></div></div></main></div></div></div><footer class="nm-custom-footer" data-testid="custom-footer"><div class="nm-footer-container"><div class="nm-footer-grid"><div class="nm-footer-brand"><div class="nm-footer-logo"><h3>Physical AI &amp; Robotics</h3><p>An AI-Native Engineering Textbook</p></div><p class="nm-footer-description">Master the convergence of artificial intelligence and physical robotics through comprehensive, hands-on learning experiences.</p><div class="nm-footer-stats"><div class="nm-stat"><div class="nm-stat-number">1000+</div><div class="nm-stat-label">Pages</div></div><div class="nm-stat"><div class="nm-stat-number">50+</div><div class="nm-stat-label">Exercises</div></div><div class="nm-stat"><div class="nm-stat-number">24/7</div><div class="nm-stat-label">Access</div></div></div></div><div class="nm-footer-section"><h4 class="nm-footer-heading">Resources</h4><ul class="nm-footer-links"><li><a href="/ai-native-textbook-docusaurus/docs/part-1-foundations/chapter-1-what-is-physical-ai">Foundations</a></li><li><a href="/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-4-ros2-fundamentals">ROS &amp; Navigation</a></li><li><a href="/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-13-computer-vision-robots">Computer Vision</a></li><li><a href="/ai-native-textbook-docusaurus/docs/part-5-embodied-intelligence/chapter-17-vision-language-action-models">Machine Learning</a></li><li><a href="/ai-native-textbook-docusaurus/docs/part-3-simulation/chapter-7-gazebo-physics-simulation">Simulation &amp; Control</a></li></ul></div><div class="nm-footer-section"><h4 class="nm-footer-heading">Learning Paths</h4><ul class="nm-footer-links"><li><a href="/ai-native-textbook-docusaurus/beginner">Beginner Track</a></li><li><a href="/ai-native-textbook-docusaurus/intermediate">Intermediate Track</a></li><li><a href="/ai-native-textbook-docusaurus/advanced">Advanced Track</a></li><li><a href="/ai-native-textbook-docusaurus/projects">Hands-on Projects</a></li><li><a href="/ai-native-textbook-docusaurus/certification">Certification</a></li></ul></div><div class="nm-footer-section"><h4 class="nm-footer-heading">Community</h4><ul class="nm-footer-links"><li><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus">GitHub</a></li><li><a href="https://discord.gg/9B6qGRZf">Discord</a></li><li><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus/discussions">Forum</a></li><li><a href="/ai-native-textbook-docusaurus/contributors">Contributors</a></li><li><a href="/ai-native-textbook-docusaurus/blog">Blog</a></li></ul></div><div class="nm-footer-section nm-footer-newsletter"><h4 class="nm-footer-heading">Stay Updated</h4><p class="nm-footer-subtext">Get the latest updates and exclusive content</p><div class="nm-newsletter-form"><input type="email" placeholder="Enter your email" class="nm-newsletter-input"><button type="button" class="nm-newsletter-button">Subscribe</button></div><div class="nm-footer-social"><a href="https://github.com/NaumanNavaid/ai-native-textbook-docusaurus" class="nm-social-link" aria-label="GitHub"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"></path></svg></a><a href="https://twitter.com/NStudio" class="nm-social-link" aria-label="Twitter"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"></path></svg></a><a href="https://linkedin.com/company/snn-studio" class="nm-social-link" aria-label="LinkedIn"><svg width="20" height="20" viewBox="0 0 24 24" fill="currentColor"><path d="M20.447 20.452h-3.554v-5.569c0-1.328-.027-3.037-1.852-3.037-1.853 0-2.136 1.445-2.136 2.939v5.667H9.351V9h3.414v1.561h.046c.477-.9 1.637-1.85 3.37-1.85 3.601 0 4.267 2.37 4.267 5.455v6.286zM5.337 7.433c-1.144 0-2.063-.926-2.063-2.065 0-1.138.92-2.063 2.063-2.063 1.14 0 2.064.925 2.064 2.063 0 1.139-.925 2.065-2.064 2.065zm1.782 13.019H3.555V9h3.564v11.452zM22.225 0H1.771C.792 0 0 .774 0 1.729v20.542C0 23.227.792 24 1.771 24h20.451C23.2 24 24 23.227 24 22.271V1.729C24 .774 23.2 0 22.222 0h.003z"></path></svg></a></div></div></div><div class="nm-footer-bottom"><div class="nm-footer-bottom-left"><span class="nm-footer-copyright"> <!-- -->2025<!-- --> AI-Native Textbook. All rights reserved. Created by SNN Studio.</span></div><div class="nm-footer-bottom-right"><a class="nm-footer-link" href="/ai-native-textbook-docusaurus/privacy">Privacy Policy</a><span class="nm-footer-separator"></span><a class="nm-footer-link" href="/ai-native-textbook-docusaurus/terms">Terms of Service</a><span class="nm-footer-separator"></span><a class="nm-footer-link" href="/ai-native-textbook-docusaurus/code-of-conduct">Code of Conduct</a></div></div></div></footer><div class="chat-widget"><button class="chat-widget-button" aria-label="Open chat"><svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg></button></div></div>
</body>
</html>