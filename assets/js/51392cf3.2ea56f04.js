"use strict";(globalThis.webpackChunkai_native_textbook_docusaurus=globalThis.webpackChunkai_native_textbook_docusaurus||[]).push([[6225],{1083:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"part-4-perception/chapter-16-path-planning-algorithms","title":"Path Planning Algorithms","description":"16.1 Path Planning Fundamentals","source":"@site/docs/part-4-perception/chapter-16-path-planning-algorithms.mdx","sourceDirName":"part-4-perception","slug":"/part-4-perception/chapter-16-path-planning-algorithms","permalink":"/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-16-path-planning-algorithms","draft":false,"unlisted":false,"editUrl":"https://github.com/NaumanNavaid/ai-native-textbook-docusaurus/tree/main/docs/part-4-perception/chapter-16-path-planning-algorithms.mdx","tags":[],"version":"current","frontMatter":{"title":"Path Planning Algorithms","part":4,"chapter":16,"difficulty":"advanced","prerequisites":["chapter-15-slam-vslam-navigation","chapter-14-sensor-fusion-state-estimation"],"estimatedTime":60,"objectives":["Master classical path planning algorithms","Implement sampling-based planners","Develop trajectory optimization techniques","Apply planning to real robotic systems"]},"sidebar":"chaptersSidebar","previous":{"title":"SLAM, VSLAM, and Navigation","permalink":"/ai-native-textbook-docusaurus/docs/part-4-perception/chapter-15-slam-vslam-navigation"},"next":{"title":"Chapter 17: Vision-Language-Action Models","permalink":"/ai-native-textbook-docusaurus/docs/part-5-embodied-intelligence/chapter-17-vision-language-action-models"}}');var i=r(4848),s=r(8453);const a={title:"Path Planning Algorithms",part:4,chapter:16,difficulty:"advanced",prerequisites:["chapter-15-slam-vslam-navigation","chapter-14-sensor-fusion-state-estimation"],estimatedTime:60,objectives:["Master classical path planning algorithms","Implement sampling-based planners","Develop trajectory optimization techniques","Apply planning to real robotic systems"]},o="Chapter 16: Path Planning Algorithms",l={},d=[{value:"16.1 Path Planning Fundamentals",id:"161-path-planning-fundamentals",level:2},{value:"16.1.1 The Path Planning Problem",id:"1611-the-path-planning-problem",level:3},{value:"16.1.2 Configuration Space",id:"1612-configuration-space",level:3},{value:"16.2 Classical Planning Algorithms",id:"162-classical-planning-algorithms",level:2},{value:"16.2.1 Dijkstra&#39;s Algorithm",id:"1621-dijkstras-algorithm",level:3},{value:"16.2.2 A* Algorithm",id:"1622-a-algorithm",level:3},{value:"16.3 Sampling-Based Planners",id:"163-sampling-based-planners",level:2},{value:"16.3.1 Probabilistic Roadmaps (PRM)",id:"1631-probabilistic-roadmaps-prm",level:3},{value:"16.3.2 Rapidly-exploring Random Trees (RRT)",id:"1632-rapidly-exploring-random-trees-rrt",level:3},{value:"16.4 Optimization-Based Planning",id:"164-optimization-based-planning",level:2},{value:"16.4.1 Trajectory Optimization",id:"1641-trajectory-optimization",level:3},{value:"Chapter Summary",id:"chapter-summary",level:2},{value:"Key Concepts Covered",id:"key-concepts-covered",level:3},{value:"Practical Implementations",id:"practical-implementations",level:3},{value:"Next Steps",id:"next-steps",level:3},{value:"Glossary Terms",id:"glossary-terms",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 16.1: A* Implementation",id:"exercise-161-a-implementation",level:3},{value:"Exercise 16.2: RRT* Planning",id:"exercise-162-rrt-planning",level:3},{value:"Exercise 8.3: Trajectory Optimization",id:"exercise-83-trajectory-optimization",level:3},{value:"Exercise 16.4: Multi-Robot Planning",id:"exercise-164-multi-robot-planning",level:3},{value:"Exercise 16.5: Dynamic Environment",id:"exercise-165-dynamic-environment",level:3}];function c(n){const e={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"chapter-16-path-planning-algorithms",children:"Chapter 16: Path Planning Algorithms"})}),"\n",(0,i.jsx)(e.h2,{id:"161-path-planning-fundamentals",children:"16.1 Path Planning Fundamentals"}),"\n",(0,i.jsx)(e.h3,{id:"1611-the-path-planning-problem",children:"16.1.1 The Path Planning Problem"}),"\n",(0,i.jsx)(e.p,{children:"Path planning finds a collision-free path from start to goal in a configuration space while optimizing criteria like shortest distance, smoothness, or execution time."}),"\n",(0,i.jsx)(e.admonition,{type:"info",children:(0,i.jsx)(e.p,{children:"Path planning differs from navigation in that it computes the geometric path, while navigation includes real-time control to follow the path. Good path planning considers both global optimality and local execution feasibility."})}),"\n",(0,i.jsx)(e.h3,{id:"1612-configuration-space",children:"16.1.2 Configuration Space"}),"\n",(0,i.jsx)(e.p,{children:"Configuration space (C-space) represents all possible robot configurations:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class ConfigurationSpace:\r\n    def __init__(self, robot_dimensions, workspace_bounds):\r\n        self.robot_width = robot_dimensions[\'width\']\r\n        self.robot_height = robot_dimensions[\'height\']\r\n        self.workspace_bounds = workspace_bounds  # [xmin, ymin, xmax, ymax]\r\n\r\n        # Configuration space resolution\r\n        self.resolution = 0.05  # 5cm grid\r\n\r\n        # Grid dimensions\r\n        self.width = int((workspace_bounds[2] - workspace_bounds[0]) / self.resolution)\r\n        self.height = int((workspace_bounds[3] - workspace_bounds[1]) / self.resolution)\r\n\r\n        # Occupancy grid\r\n        self.occupancy_grid = np.zeros((self.width, self.height), dtype=np.uint8)\r\n        self.obstacles = []\r\n\r\n    def add_obstacle(self, obstacle):\r\n        """Add obstacle to configuration space"""\r\n        self.obstacles.append(obstacle)\r\n        self._update_occupancy_grid(obstacle)\r\n\r\n    def _update_occupancy_grid(self, obstacle):\r\n        """Update occupancy grid for Minkowski sum with robot footprint"""\r\n        # Get obstacle pixels\r\n        obstacle_pixels = self._world_to_grid(obstacle.get_pixels())\r\n\r\n        # Expand for robot footprint (Minkowski sum)\r\n        robot_radius_pixels = int(max(self.robot_width, self.robot_height) / (2 * self.resolution))\r\n\r\n        for pixel in obstacle_pixels:\r\n            x, y = pixel\r\n            # Draw filled circle for robot footprint\r\n            for dx in range(-robot_radius_pixels, robot_radius_pixels + 1):\r\n                for dy in range(-robot_radius_pixels, robot_radius_pixels + 1):\r\n                    if dx*dx + dy*dy <= robot_radius_pixels*robot_radius_pixels:\r\n                        nx, ny = x + dx, y + dy\r\n                        if 0 <= nx < self.width and 0 <= ny < self.height:\r\n                            self.occupancy_grid[nx, ny] = 1\r\n\r\n    def world_to_grid(self, world_point):\r\n        """Convert world coordinates to grid coordinates"""\r\n        x = int((world_point[0] - self.workspace_bounds[0]) / self.resolution)\r\n        y = int((world_point[1] - self.workspace_bounds[1]) / self.resolution)\r\n        return x, y\r\n\r\n    def grid_to_world(self, grid_point):\r\n        """Convert grid coordinates to world coordinates"""\r\n        x = grid_point[0] * self.resolution + self.workspace_bounds[0]\r\n        y = grid_point[1] * self.resolution + self.workspace_bounds[1]\r\n        return np.array([x, y])\r\n\r\n    def is_collision_free(self, position):\r\n        """Check if position is collision-free"""\r\n        grid_point = self.world_to_grid(position)\r\n\r\n        if not self._is_valid_grid(grid_point):\r\n            return False\r\n\r\n        return self.occupancy_grid[grid_point[0], grid_point[1]] == 0\r\n\r\n    def _is_valid_grid(self, grid_point):\r\n        """Check if grid point is within bounds"""\r\n        x, y = grid_point\r\n        return 0 <= x < self.width and 0 <= y < self.height\r\n\r\n    def is_path_collision_free(self, path):\r\n        """Check if entire path is collision-free"""\r\n        for position in path:\r\n            if not self.is_collision_free(position):\r\n                return False\r\n\r\n        return True\n'})}),"\n",(0,i.jsx)(e.h2,{id:"162-classical-planning-algorithms",children:"16.2 Classical Planning Algorithms"}),"\n",(0,i.jsx)(e.h3,{id:"1621-dijkstras-algorithm",children:"16.2.1 Dijkstra's Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"Dijkstra's algorithm finds the shortest path in weighted graphs:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class DijkstraPlanner:\r\n    def __init__(self, config_space):\r\n        self.config_space = config_space\r\n        self.grid = config_space.occupancy_grid\r\n        self.width = config_space.width\r\n        self.height = config_space.height\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using Dijkstra\'s algorithm"""\r\n        start_grid = self.config_space.world_to_grid(start)\r\n        goal_grid = self.config_space.world_to_grid(goal)\r\n\r\n        if not self._is_valid_start_goal(start_grid, goal_grid):\r\n            return None\r\n\r\n        # Initialize distances\r\n        distances = np.full((self.width, self.height), np.inf)\r\n        distances[start_grid[0], start_grid[1]] = 0\r\n\r\n        # Parent tracking\r\n        parents = np.zeros((self.width, self.height, 2), dtype=int)\r\n        parents[start_grid[0], start_grid[1]] = start_grid\r\n\r\n        # Priority queue (min-heap)\r\n        open_set = []\r\n        heapq.heappush(open_set, (0, start_grid))\r\n\r\n        # Visited set\r\n        closed_set = set()\r\n\r\n        while open_set:\r\n            # Get node with minimum distance\r\n            current_distance, current_grid = heapq.heappop(open_set)\r\n\r\n            if current_grid == goal_grid:\r\n                # Goal reached - reconstruct path\r\n                return self._reconstruct_path(parents, start_grid, goal_grid)\r\n\r\n            closed_set.add(current_grid)\r\n\r\n            # Explore neighbors\r\n            for neighbor in self._get_neighbors(current_grid):\r\n                if neighbor in closed_set:\r\n                    continue\r\n\r\n                # Edge cost (uniform for grid)\r\n                edge_cost = 1.0\r\n                new_distance = current_distance + edge_cost\r\n\r\n                if new_distance < distances[neighbor[0], neighbor[1]]:\r\n                    distances[neighbor[0], neighbor[1]] = new_distance\r\n                    parents[neighbor[0], neighbor[1]] = current_grid\r\n                    heapq.heappush(open_set, (new_distance, neighbor))\r\n\r\n        return None  # No path found\r\n\r\n    def _get_neighbors(self, grid_point):\r\n        """Get valid neighboring grid cells"""\r\n        neighbors = []\r\n        directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]  # 4-connected\r\n\r\n        for dx, dy in directions:\r\n            neighbor = (grid_point[0] + dx, grid_point[1] + dy)\r\n            if self._is_valid_neighbor(neighbor):\r\n                neighbors.append(neighbor)\r\n\r\n        return neighbors\r\n\r\n    def _is_valid_neighbor(self, grid_point):\r\n        """Check if neighbor is valid and collision-free"""\r\n        x, y = grid_point\r\n        return (0 <= x < self.width and\r\n                0 <= y < self.height and\r\n                self.grid[x, y] == 0)\r\n\r\n    def _is_valid_start_goal(self, start_grid, goal_grid):\r\n        """Validate start and goal positions"""\r\n        return (self._is_valid_neighbor(start_grid) and\r\n                self._is_valid_neighbor(goal_grid))\r\n\r\n    def _reconstruct_path(self, parents, start_grid, goal_grid):\r\n        """Reconstruct path from parent pointers"""\r\n        path = [goal_grid]\r\n        current = goal_grid\r\n\r\n        while not np.array_equal(current, start_grid):\r\n            current = tuple(parents[current[0], current[1]])\r\n            path.append(current)\r\n\r\n        path.reverse()\r\n\r\n        # Convert to world coordinates\r\n        world_path = [self.config_space.grid_to_world(grid) for grid in path]\r\n        return world_path\n'})}),"\n",(0,i.jsx)(e.h3,{id:"1622-a-algorithm",children:"16.2.2 A* Algorithm"}),"\n",(0,i.jsx)(e.p,{children:"A* algorithm uses heuristics to guide search more efficiently:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class AStarPlanner:\r\n    def __init__(self, config_space, heuristic_weight=1.0):\r\n        self.config_space = config_space\r\n        self.grid = config_space.occupancy_grid\r\n        self.width = config_space.width\r\n        self.height = config_space.height\r\n        self.heuristic_weight = heuristic_weight\r\n\r\n        # Precompute heuristic\r\n        self._precompute_heuristic()\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using A* algorithm"""\r\n        start_grid = self.config_space.world_to_grid(start)\r\n        goal_grid = self.config_space.world_to_grid(goal)\r\n\r\n        if not self._is_valid_start_goal(start_grid, goal_grid):\r\n            return None\r\n\r\n        # Node structure: (f_cost, g_cost, grid_point, parent)\r\n        open_set = []\r\n        start_h = self._heuristic(start_grid, goal_grid)\r\n        heapq.heappush(open_set, (start_h, 0, start_grid, None))\r\n\r\n        # Distance to goal\r\n        distances = np.full((self.width, self.height), np.inf)\r\n        distances[start_grid[0], start_grid[1]] = 0\r\n\r\n        # Closed set\r\n        closed_set = set()\r\n\r\n        while open_set:\r\n            # Get node with minimum f_cost\r\n            f_cost, g_cost, current_grid, parent = heapq.heappop(open_set)\r\n\r\n            if current_grid == goal_grid:\r\n                # Goal reached - reconstruct path\r\n                return self._reconstruct_path(parent, start_grid, goal_grid)\r\n\r\n            closed_set.add(current_grid)\r\n\r\n            # Explore neighbors\r\n            for neighbor in self._get_neighbors(current_grid):\r\n                if neighbor in closed_set:\r\n                    continue\r\n\r\n                # Movement cost\r\n                edge_cost = self._edge_cost(current_grid, neighbor)\r\n                tentative_g_cost = g_cost + edge_cost\r\n\r\n                if tentative_g_cost < distances[neighbor[0], neighbor[1]]:\r\n                    distances[neighbor[0], neighbor[1]] = tentative_g_cost\r\n\r\n                    h_cost = self._heuristic(neighbor, goal_grid)\r\n                    f_cost = tentative_g_cost + self.heuristic_weight * h_cost\r\n\r\n                    heapq.heappush(open_set, (f_cost, tentative_g_cost, neighbor, current_grid))\r\n\r\n        return None  # No path found\r\n\r\n    def _heuristic(self, grid1, grid2):\r\n        """A* heuristic (Euclidean distance)"""\r\n        # Use precomputed values for speed\r\n        return self.precomputed_heuristic[grid1[0], grid1[1], grid2[0], grid2[1]]\r\n\r\n    def _precompute_heuristic(self):\r\n        """Precompute heuristic values for all grid pairs"""\r\n        self.precomputed_heuristic = np.zeros((self.width, self.height, self.width, self.height))\r\n\r\n        for x1 in range(self.width):\r\n            for y1 in range(self.height):\r\n                for x2 in range(self.width):\r\n                    for y2 in range(self.height):\r\n                        dx = abs(x2 - x1)\r\n                        dy = abs(y2 - y1)\r\n                        self.precomputed_heuristic[x1, y1, x2, y2] = np.sqrt(dx*dx + dy*dy)\r\n\r\n    def _edge_cost(self, from_grid, to_grid):\r\n        """Calculate edge cost between grid cells"""\r\n        dx = abs(to_grid[0] - from_grid[0])\r\n        dy = abs(to_grid[1] - from_grid[1])\r\n\r\n        if dx == 1 and dy == 1:\r\n            return 1.414  # Diagonal movement\r\n        else:\r\n            return 1.0  # Cardinal movement\r\n\r\nclass ThetaStarPlanner:\r\n    def __init__(self, config_space):\r\n        self.config_space = config_space\r\n        self.grid = config_space.occupancy_grid\r\n        self.width = config_space.width\r\n        self.height = config_space.height\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path considering robot orientation"""\r\n        start_grid = self.config_space.world_to_grid(start)\r\n        start_theta = int(start[2] * 180 / np.pi) % 360\r\n        goal_grid = self.config_space.world_to_grid(goal)\r\n        goal_theta = int(goal[2] * 180 / np.pi) % 360\r\n\r\n        # 3D state space: (x, y, theta)\r\n        start_state = (start_grid[0], start_grid[1], start_theta)\r\n        goal_state = (goal_grid[0], goal_grid[1], goal_theta)\r\n\r\n        # Priority queue: (f_cost, g_cost, state, parent)\r\n        open_set = []\r\n        start_h = self._heuristic_3d(start_state, goal_state)\r\n        heapq.heappush(open_set, (start_h, 0, start_state, None))\r\n\r\n        # Visited states\r\n        visited = set()\r\n        visited.add(start_state)\r\n\r\n        # Parent tracking\r\n        parents = {}\r\n\r\n        while open_set:\r\n            f_cost, g_cost, current_state, parent = heapq.heappop(open_set)\r\n\r\n            if self._is_goal(current_state, goal_state):\r\n                return self._reconstruct_path_3d(parents, start_state, goal_state)\r\n\r\n            # Generate successor states\r\n            successors = self._get_successors_3d(current_state)\r\n\r\n            for successor_state, action_cost in successors:\r\n                if successor_state not in visited:\r\n                    visited.add(successor_state)\r\n\r\n                    tentative_g_cost = g_cost + action_cost\r\n                    h_cost = self._heuristic_3d(successor_state, goal_state)\r\n                    f_cost = tentative_g_cost + h_cost\r\n\r\n                    heapq.heappush(open_set, (f_cost, tentative_g_cost, successor_state, current_state))\r\n                    parents[successor_state] = current_state\r\n\r\n        return None\r\n\r\n    def _get_successors_3d(self, state):\r\n        """Get successor states in 3D configuration space"""\r\n        successors = []\r\n        x, y, theta = state\r\n\r\n        # Position movements (4-connected)\r\n        movements = [(1, 0), (0, 1), (-1, 0), (0, -1)]\r\n\r\n        for dx, dy in movements:\r\n            new_x, new_y = x + dx, y + dy\r\n            new_theta = theta\r\n\r\n            if self._is_valid_position(new_x, new_y):\r\n                successors.append(((new_x, new_y, new_theta), 1.0))\r\n\r\n        # Orientation changes (45-degree steps)\r\n        angle_steps = [45, -45]\r\n        for dtheta in angle_steps:\r\n            new_theta = (theta + dtheta) % 360\r\n            successors.append(((x, y, new_theta), 0.5))\r\n\r\n        return successors\r\n\r\n    def _heuristic_3d(self, state1, state2):\r\n        """3D heuristic combining position and orientation"""\r\n        x1, y1, theta1 = state1\r\n        x2, y2, theta2 = state2\r\n\r\n        # Position heuristic\r\n        dx = abs(x2 - x1)\r\n        dy = abs(y2 - y1)\r\n        position_cost = np.sqrt(dx*dx + dy*dy)\r\n\r\n        # Orientation heuristic (normalized to [0, 1])\r\n        theta_diff = abs(theta2 - theta1)\r\n        theta_diff = min(theta_diff, 360 - theta_diff)\r\n        orientation_cost = theta_diff / 360.0\r\n\r\n        # Weighted combination\r\n        return position_cost + 0.1 * orientation_cost\n'})}),"\n",(0,i.jsx)(e.h2,{id:"163-sampling-based-planners",children:"16.3 Sampling-Based Planners"}),"\n",(0,i.jsx)(e.h3,{id:"1631-probabilistic-roadmaps-prm",children:"16.3.1 Probabilistic Roadmaps (PRM)"}),"\n",(0,i.jsx)(e.p,{children:"PRM builds a roadmap of collision-free paths:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class ProbabilisticRoadmap:\r\n    def __init__(self, config_space, num_samples=1000, connection_radius=2.0):\r\n        self.config_space = config_space\r\n        self.num_samples = num_samples\r\n        self.connection_radius = connection_radius\r\n\r\n        # Roadmap structure\r\n        self.nodes = []  # List of (x, y) positions\r\n        self.edges = []  # List of (node1, node2, distance) edges\r\n\r\n    def build_roadmap(self):\r\n        """Build probabilistic roadmap"""\r\n        print("Building PRM roadmap...")\r\n\r\n        # Step 1: Generate random collision-free samples\r\n        self._generate_samples()\r\n\r\n        # Step 2: Connect nearby samples\r\n        self._connect_samples()\r\n\r\n        print(f"Roadmap built with {len(self.nodes)} nodes and {len(self.edges)} edges")\r\n\r\n    def _generate_samples(self):\r\n        """Generate random collision-free samples"""\r\n        samples_generated = 0\r\n        attempts = 0\r\n        max_attempts = self.num_samples * 10\r\n\r\n        while samples_generated < self.num_samples and attempts < max_attempts:\r\n            # Generate random sample\r\n            x = np.random.uniform(self.config_space.workspace_bounds[0],\r\n                               self.config_space.workspace_bounds[2])\r\n            y = np.random.uniform(self.config_space.workspace_bounds[1],\r\n                               self.config_space.workspace_bounds[3])\r\n\r\n            # Check if collision-free\r\n            if self.config_space.is_collision_free((x, y)):\r\n                self.nodes.append((x, y))\r\n                samples_generated += 1\r\n\r\n            attempts += 1\r\n\r\n    def _connect_samples(self):\r\n        """Connect nearby samples in roadmap"""\r\n        for i in range(len(self.nodes)):\r\n            for j in range(i + 1, len(self.nodes)):\r\n                # Calculate Euclidean distance\r\n                distance = np.linalg.norm(np.array(self.nodes[i]) - np.array(self.nodes[j]))\r\n\r\n                if distance <= self.connection_radius:\r\n                    # Check if connection is collision-free\r\n                    if self._is_path_collision_free(self.nodes[i], self.nodes[j]):\r\n                        self.edges.append((i, j, distance))\r\n                        self.edges.append((j, i, distance))\r\n\r\n    def _is_path_collision_free(self, point1, point2):\r\n        """Check if straight-line path between points is collision-free"""\r\n        # Sample points along the line\r\n        num_samples = int(np.linalg.norm(np.array(point2) - np.array(point1)) / 0.05)\r\n\r\n        if num_samples < 2:\r\n            return self.config_space.is_collision_free(point1) and \\\r\n                   self.config_space.is_collision_free(point2)\r\n\r\n        for t in np.linspace(0, 1, num_samples):\r\n            point = point1 + t * (np.array(point2) - np.array(point1))\r\n            if not self.config_space.is_collision_free(point):\r\n                return False\r\n\r\n        return True\r\n\r\n    def plan_path(self, start, goal):\r\n        """Find path using built roadmap"""\r\n        start_idx = self._find_nearest_node(start)\r\n        goal_idx = self._find_nearest_node(goal)\r\n\r\n        if start_idx is None or goal_idx is None:\r\n            return None\r\n\r\n        # Connect start and goal to roadmap\r\n        connected_edges = self._connect_to_roadmap(start, start_idx, goal, goal_idx)\r\n\r\n        if not connected_edges:\r\n            return None\r\n\r\n        # Find path using Dijkstra on roadmap graph\r\n        path_indices = self._find_path_in_graph(start_idx, goal_idx)\r\n\r\n        if path_indices is None:\r\n            return None\r\n\r\n        # Convert indices to positions\r\n        path = [self.nodes[idx] for idx in path_indices]\r\n\r\n        return path\r\n\r\n    def _find_nearest_node(self, point):\r\n        """Find nearest node in roadmap"""\r\n        min_distance = float(\'inf\')\r\n        nearest_idx = None\r\n\r\n        for i, node in enumerate(self.nodes):\r\n            distance = np.linalg.norm(np.array(node) - np.array(point))\r\n            if distance < min_distance:\r\n                min_distance = distance\r\n                nearest_idx = i\r\n\r\n        return nearest_idx if min_distance < self.connection_radius else None\r\n\r\n    def _connect_to_roadmap(self, start, start_idx, goal, goal_idx):\r\n        """Connect start and goal points to roadmap"""\r\n        # Connect start to nearest node\r\n        if start_idx is not None:\r\n            if self.config_space.is_path_collision_free(start, self.nodes[start_idx]):\r\n                self.nodes.append(start)\r\n                new_start_idx = len(self.nodes) - 1\r\n                self.edges.append((new_start_idx, start_idx,\r\n                                np.linalg.norm(np.array(start) - np.array(self.nodes[start_idx]))))\r\n            else:\r\n                return False\r\n\r\n        # Connect goal to nearest node\r\n        if goal_idx is not None:\r\n            if self.config_space.is_path_collision_free(goal, self.nodes[goal_idx]):\r\n                self.nodes.append(goal)\r\n                new_goal_idx = len(self.nodes) - 1\r\n                self.edges.append((goal_idx, new_goal_idx,\r\n                                np.linalg.norm(np.array(goal) - np.array(self.nodes[goal_idx]))))\r\n            else:\r\n                return False\r\n\r\n        return True\r\n\r\n    def _find_path_in_graph(self, start_idx, goal_idx):\r\n        """Find shortest path in graph using Dijkstra"""\r\n        num_nodes = len(self.nodes)\r\n        if num_nodes == 0:\r\n            return None\r\n\r\n        # Build adjacency list\r\n        adjacency = [[] for _ in range(num_nodes)]\r\n        for edge in self.edges:\r\n            adjacency[edge[0]].append((edge[1], edge[2]))\r\n            adjacency[edge[1]].append((edge[0], edge[2]))\r\n\r\n        # Dijkstra\'s algorithm\r\n        distances = np.full(num_nodes, np.inf)\r\n        distances[start_idx] = 0\r\n\r\n        parents = np.full(num_nodes, -1)\r\n        visited = [False] * num_nodes\r\n\r\n        pq = [(0, start_idx)]\r\n\r\n        while pq:\r\n            dist, current = heapq.heappop(pq)\r\n\r\n            if visited[current]:\r\n                continue\r\n\r\n            visited[current] = True\r\n\r\n            if current == goal_idx:\r\n                # Reconstruct path\r\n                path = []\r\n                node = current\r\n                while node != -1:\r\n                    path.append(node)\r\n                    node = parents[node]\r\n                return path[::-1]\r\n\r\n            for neighbor, edge_dist in adjacency[current]:\r\n                new_dist = dist + edge_dist\r\n                if new_dist < distances[neighbor]:\r\n                    distances[neighbor] = new_dist\r\n                    parents[neighbor] = current\r\n                    heapq.heappush(pq, (new_dist, neighbor))\r\n\r\n        return None  # No path found\n'})}),"\n",(0,i.jsx)(e.h3,{id:"1632-rapidly-exploring-random-trees-rrt",children:"16.3.2 Rapidly-exploring Random Trees (RRT)"}),"\n",(0,i.jsx)(e.p,{children:"RRT rapidly explores configuration space with random sampling:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class RRTPlanner:\r\n    def __init__(self, config_space, max_iterations=5000, step_size=0.5):\r\n        self.config_space = config_space\r\n        self.max_iterations = max_iterations\r\n        self.step_size = step_size\r\n\r\n        # Tree structure\r\n        self.tree = []\r\n        self.parent = []\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using RRT"""\r\n        # Initialize tree with start point\r\n        self.tree = [start]\r\n        self.parent = [-1]\r\n\r\n        goal_tolerance = self.step_size\r\n\r\n        for iteration in range(self.max_iterations):\r\n            # Sample random point\r\n            if np.random.random() < 0.1:  # 10% chance to sample goal\r\n                random_point = goal\r\n            else:\r\n                random_point = self._sample_random_point()\r\n\r\n            # Find nearest node in tree\r\n            nearest_idx = self._find_nearest_node(random_point)\r\n            nearest_node = self.tree[nearest_idx]\r\n\r\n            # Extend tree towards random point\r\n            new_node = self._extend_towards(nearest_node, random_point)\r\n\r\n            # Check if extension is valid\r\n            if self.config_space.is_collision_free(new_node):\r\n                # Add to tree\r\n                self.tree.append(new_node)\r\n                self.parent.append(nearest_idx)\r\n\r\n                # Check if goal reached\r\n                if np.linalg.norm(np.array(new_node) - np.array(goal)) < goal_tolerance:\r\n                    return self._reconstruct_path_to_root(len(self.tree) - 1)\r\n\r\n        return None  # No path found\r\n\r\n    def _sample_random_point(self):\r\n        """Sample random point in configuration space"""\r\n        x = np.random.uniform(self.config_space.workspace_bounds[0],\r\n                               self.config_space.workspace_bounds[2])\r\n        y = np.random.uniform(self.config_space.workspace_bounds[1],\r\n                               self.config_space.workspace_bounds[3])\r\n        return np.array([x, y])\r\n\r\n    def _find_nearest_node(self, point):\r\n        """Find nearest node in tree"""\r\n        min_distance = float(\'inf)\r\n        nearest_idx = 0\r\n\r\n        for i, node in enumerate(self.tree):\r\n            distance = np.linalg.norm(np.array(node) - np.array(point))\r\n            if distance < min_distance:\r\n                min_distance = distance\r\n                nearest_idx = i\r\n\r\n        return nearest_idx\r\n\r\n    def _extend_towards(self, from_node, to_point):\r\n        """Extend tree from node towards point"""\r\n        direction = np.array(to_point) - np.array(from_node)\r\n        distance = np.linalg.norm(direction)\r\n\r\n        if distance <= self.step_size:\r\n            return to_point\r\n        else:\r\n            # Normalize and step\r\n            direction = direction / distance\r\n            return np.array(from_node) + direction * self.step_size\r\n\r\n    def _reconstruct_path_to_root(self, node_idx):\r\n        """Reconstruct path from node to root"""\r\n        path = []\r\n        current = node_idx\r\n\r\n        while current != -1:\r\n            path.append(self.tree[current])\r\n            current = self.parent[current]\r\n\r\n        return path[::-1]\r\n\r\nclass RRTStarPlanner(RRTPlanner):\r\n    def __init__(self, config_space, max_iterations=5000, step_size=0.5, rewire_radius=1.0):\r\n        super().__init__(config_space, max_iterations, step_size)\r\n        self.rewire_radius = rewire_radius\r\n\r\n    def plan_path(self, start, goal):\r\n        """Plan path using RRT* with rewiring"""\r\n        # Initialize tree with start point\r\n        self.tree = [start]\r\n        self.parent = [-1]\r\n\r\n        # Track costs\r\n        self.costs = [0.0]\r\n\r\n        goal_tolerance = self.step_size\r\n\r\n        for iteration in range(self.max_iterations):\r\n            # Sample random point\r\n            if np.random.random() < 0.1:\r\n                random_point = goal\r\n            else:\r\n                random_point = self._sample_random_point()\r\n\r\n            # Find nearest node\r\n            nearest_idx = self._find_nearest_node(random_point)\r\n            nearest_node = self.tree[nearest_idx]\r\n            nearest_cost = self.costs[nearest_idx]\r\n\r\n            # Extend tree\r\n            new_node = self._extend_towards(nearest_node, random_point)\r\n            new_idx = len(self.tree)\r\n\r\n            if self.config_space.is_collision_free(new_node):\r\n                # Calculate cost\r\n                edge_cost = np.linalg.norm(np.array(new_node) - np.array(nearest_node))\r\n                new_cost = nearest_cost + edge_cost\r\n\r\n                # Add to tree\r\n                self.tree.append(new_node)\r\n                self.parent.append(nearest_idx)\r\n                self.costs.append(new_cost)\r\n\r\n                # Check if goal reached\r\n                if np.linalg.norm(np.array(new_node) - np.array(goal)) < goal_tolerance:\r\n                    return self._reconstruct_path_to_root(new_idx)\r\n\r\n                # Rewiring step\r\n                self._rewire_tree(new_idx)\r\n\r\n        return None\r\n\r\n    def _rewire_tree(self, new_node_idx):\r\n        """Rewire tree for optimal cost paths"""\r\n        new_node = self.tree[new_node_idx]\r\n\r\n        # Find nodes within rewire radius\r\n        for i, node in enumerate(self.tree):\r\n            if i == new_node_idx:\r\n                continue\r\n\r\n            distance = np.linalg.norm(np.array(node) - np.array(new_node))\r\n\r\n            if distance < self.rewire_radius:\r\n                # Calculate new cost through this node\r\n                edge_cost = distance\r\n                new_cost = self.costs[i] + edge_cost\r\n\r\n                # Rewire if better path\r\n                if new_cost < self.costs[new_node_idx]:\r\n                    self.parent[new_node_idx] = i\r\n                    self.costs[new_node_idx] = new_cost\r\n\r\n                    # Update costs of children\r\n                    self._update_children_costs(new_node_idx)\r\n\r\n    def _update_children_costs(self, parent_idx):\r\n        """Update costs of children after rewiring"""\r\n        parent_cost = self.costs[parent_idx]\r\n\r\n        for i, parent in enumerate(self.parent):\r\n            if parent == parent_idx:\r\n                edge_cost = np.linalg.norm(\r\n                    np.array(self.tree[i]) - np.array(self.tree[parent_idx])\r\n                )\r\n                self.costs[i] = parent_cost + edge_cost\r\n                self._update_children_costs(i)\n'})}),"\n",(0,i.jsx)(e.h2,{id:"164-optimization-based-planning",children:"16.4 Optimization-Based Planning"}),"\n",(0,i.jsx)(e.h3,{id:"1641-trajectory-optimization",children:"16.4.1 Trajectory Optimization"}),"\n",(0,i.jsx)(e.p,{children:"Optimize smooth trajectories for robot execution:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-python",children:'class TrajectoryOptimizer:\r\n    def __init__(self, config_space):\r\n        self.config_space = config_space\r\n        self.dt = 0.1  # Time step\r\n        self.max_velocity = 2.0\r\n        self.max_acceleration = 1.0\r\n\r\n    def optimize_trajectory(self, path, initial_guess=None):\r\n        """Optimize smooth trajectory from waypoints"""\r\n        if len(path) < 2:\r\n            return path\r\n\r\n        # Create initial trajectory guess\r\n        if initial_guess is None:\r\n            trajectory = self._create_initial_trajectory(path)\r\n        else:\r\n            trajectory = initial_guess.copy()\r\n\r\n        # Optimization parameters\r\n        iterations = 100\r\n        learning_rate = 0.1\r\n\r\n        for iteration in range(iterations):\r\n            # Compute gradient\r\n            gradient = self._compute_gradient(trajectory, path)\r\n\r\n            # Update trajectory\r\n            trajectory = trajectory - learning_rate * gradient\r\n\r\n            # Apply constraints\r\n            trajectory = self._apply_constraints(trajectory)\r\n\r\n            # Check for collisions\r\n            if self._is_trajectory_collision_free(trajectory):\r\n                break\r\n\r\n        return trajectory\r\n\r\n    def _create_initial_trajectory(self, path):\r\n        """Create initial trajectory from waypoints"""\r\n        trajectory = []\r\n\r\n        for i in range(len(path) - 1):\r\n            start = path[i]\r\n            end = path[i + 1]\r\n\r\n            # Number of intermediate points\r\n            distance = np.linalg.norm(end - start)\r\n            num_points = max(2, int(distance / (self.max_velocity * self.dt)))\r\n\r\n            for t in np.linspace(0, 1, num_points):\r\n                # Linear interpolation\r\n                point = start + t * (end - start)\r\n                trajectory.append(point)\r\n\r\n        return np.array(trajectory)\r\n\r\n    def _compute_gradient(self, trajectory, path):\r\n        """Compute gradient of cost function"""\r\n        n_points = len(trajectory)\r\n        gradient = np.zeros_like(trajectory)\r\n\r\n        # Smoothness gradient\r\n        for i in range(1, n_points - 1):\r\n            # Second derivative\r\n            d2p = trajectory[i+1] - 2 * trajectory[i] + trajectory[i-1]\r\n\r\n            # Weight for smoothness\r\n            weight = 1.0\r\n            gradient[i] += 2 * weight * d2p\r\n\r\n        # Waypoint attraction gradient\r\n        waypoint_attraction_weight = 2.0\r\n\r\n        for i, point in enumerate(trajectory):\r\n            # Find nearest waypoint\r\n            min_dist = float(\'inf)\r\n            nearest_waypoint = None\r\n            waypoint_idx = 0\r\n\r\n            for j, waypoint in enumerate(path):\r\n                dist = np.linalg.norm(point - waypoint)\r\n                if dist < min_dist:\r\n                    min_dist = dist\r\n                    nearest_waypoint = waypoint\r\n                    waypoint_idx = j\r\n\r\n            if min_dist > 0:\r\n                # Attract towards waypoint\r\n                direction = nearest_waypoint - point\r\n                gradient[i] += waypoint_attraction_weight * direction\r\n\r\n        return gradient\r\n\r\n    def _apply_constraints(self, trajectory):\r\n        """Apply velocity and acceleration constraints"""\r\n        n_points = len(trajectory)\r\n\r\n        for i in range(n_points):\r\n            # Velocity constraint\r\n            if i > 0:\r\n                velocity = (trajectory[i] - trajectory[i-1]) / self.dt\r\n                velocity_norm = np.linalg.norm(velocity)\r\n\r\n                if velocity_norm > self.max_velocity:\r\n                    velocity = velocity / velocity_norm * self.max_velocity\r\n                    trajectory[i] = trajectory[i-1] + velocity * self.dt\r\n\r\n            # Acceleration constraint\r\n            if i > 1:\r\n                acceleration = (trajectory[i] - 2*trajectory[i-1] + trajectory[i-2]) / (self.dt**2)\r\n                acc_norm = np.linalg.norm(acceleration)\r\n\r\n                if acc_norm > self.max_acceleration:\r\n                    acceleration = acceleration / acc_norm * self.max_acceleration\r\n                    trajectory[i] = 2*trajectory[i-1] - trajectory[i-2] + acceleration * (self.dt**2)\r\n\r\n        return trajectory\r\n\r\n    def _is_trajectory_collision_free(self, trajectory):\r\n        """Check if entire trajectory is collision-free"""\r\n        for point in trajectory:\r\n            if not self.config_space.is_collision_free(point):\r\n                return False\r\n        return True\r\n\r\nclass CHOMPPlanner:\r\n    def __init__(self, config_space):\r\n        self.config_space = config_space\r\n        self.max_iterations = 100\r\n        self.tolerance = 0.1\r\n\r\n    def plan_with_chomp(self, start, goal):\r\n        """Plan path using CHOMP optimization"""\r\n        # Initial guess - straight line path\r\n        initial_path = self._straight_line_path(start, goal)\r\n\r\n        if not self.config_space.is_path_collision_free(initial_path):\r\n            # Try to find collision-free initial path\r\n            initial_path = self._find_initial_path(start, goal)\r\n\r\n        if initial_path is None:\r\n            return None\r\n\r\n        # Optimize path using CHOMP\r\n        optimized_path = self._optimize_path_chomp(initial_path, start, goal)\r\n\r\n        return optimized_path\r\n\r\n    def _optimize_path_chomp(self, path, start, goal):\r\n        """Optimize path using CHOMP algorithm"""\r\n        current_path = path.copy()\r\n\r\n        for iteration in range(self.max_iterations):\r\n            # Compute gradient\r\n            gradient = self._chomp_gradient(current_path, start, goal)\r\n\r\n            # Update path\r\n            current_path = current_path - 0.1 * gradient\r\n\r\n            # Check collision constraints\r\n            max_violation = self._check_collision_constraints(current_path)\r\n\r\n            if max_violation < self.tolerance:\r\n                break\r\n\r\n            # Project back into collision-free space\r\n            current_path = self._project_collision_free(current_path, max_violation)\r\n\r\n        return current_path\r\n\r\n    def _chomp_gradient(self, path, start, goal):\r\n        """Compute CHOMP gradient"""\r\n        n_points = len(path)\r\n        gradient = np.zeros_like(path)\r\n\r\n        # Obstacle gradient\r\n        for i, point in enumerate(path):\r\n            # Find nearest obstacle\r\n            nearest_obstacle, distance = self._find_nearest_obstacle(point)\r\n\r\n            if distance > 0:\r\n                # Gradient away from obstacle\r\n                direction = point - nearest_obstacle\r\n                norm = np.linalg.norm(direction)\r\n\r\n                if norm > 0:\r\n                    # Use potential field gradient\r\n                    influence_radius = 2.0\r\n                    if distance < influence_radius:\r\n                        gradient_magnitude = (1/distance - 1/influence_radius)\r\n                        gradient[i] += gradient_magnitude * direction / norm\r\n\r\n        # Smoothness gradient\r\n        for i in range(1, n_points - 1):\r\n            d2p = path[i+1] - 2 * path[i] + path[i-1]\r\n            gradient[i] += 2 * d2p\r\n\r\n        # Goal attraction gradient\r\n        for i in range(n_points):\r\n            # Progress towards goal along path\r\n            if i < n_points - 1:\r\n                remaining = path[-1] - path[i]\r\n                progress = (i + 1) / n_points\r\n                desired = path[i] + progress * remaining\r\n                gradient[i] += 2 * (desired - path[i])\r\n\r\n        # Start point constraint\r\n        gradient[0] += 10 * (start - path[0])\r\n\r\n        return gradient\r\n\r\n    def _find_nearest_obstacle(self, point):\r\n        """Find nearest obstacle point"""\r\n        min_distance = float(\'inf)\r\n        nearest_point = point.copy()\r\n\r\n        # Check grid cells in neighborhood\r\n        grid_x, grid_y = self.config_space.world_to_grid(point)\r\n        search_radius = 5\r\n\r\n        for dx in range(-search_radius, search_radius + 1):\r\n            for dy in range(-search_radius, search_radius + 1):\r\n                check_x, check_y = grid_x + dx, grid_y + dy\r\n\r\n                if (0 <= check_x < self.config_space.width and\r\n                    0 <= check_y < self.config_space.height and\r\n                    self.config_space.occupancy_grid[check_x, check_y] > 0):\r\n\r\n                    obstacle_point = self.config_space.grid_to_world((check_x, check_y))\r\n                    distance = np.linalg.norm(point - obstacle_point)\r\n\r\n                    if distance < min_distance:\r\n                        min_distance = distance\r\n                        nearest_point = obstacle_point.copy()\r\n\r\n        return nearest_point, min_distance\n'})}),"\n",(0,i.jsx)(e.h2,{id:"chapter-summary",children:"Chapter Summary"}),"\n",(0,i.jsx)(e.p,{children:"This chapter covered comprehensive path planning algorithms for robotics:"}),"\n",(0,i.jsx)(e.h3,{id:"key-concepts-covered",children:"Key Concepts Covered"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Configuration Space"}),": Mathematical representation of robot configurations"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Classical Planners"}),": Dijkstra's algorithm and A* with heuristics"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Sampling-Based Planners"}),": PRM and RRT/RRT* for high-dimensional spaces"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Optimization-Based Planning"}),": CHOMP and trajectory optimization"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Path Execution"}),": Control laws and trajectory following"]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.strong,{children:"Practical Considerations"}),": Computational efficiency and real-time constraints"]}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"practical-implementations",children:"Practical Implementations"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Complete configuration space representation with Minkowski sum"}),"\n",(0,i.jsx)(e.li,{children:"A* planner with precomputed heuristics and Theta* variant"}),"\n",(0,i.jsx)(e.li,{children:"PRM with probabilistic sampling and connection strategies"}),"\n",(0,i.jsx)(e.li,{children:"RRT and RRT* with rewiring for optimal paths"}),"\n",(0,i.jsx)(e.li,{children:"Trajectory optimization with smoothness and dynamics constraints"}),"\n",(0,i.jsx)(e.li,{children:"CHOMP optimization with obstacle avoidance using potential fields"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"next-steps",children:"Next Steps"}),"\n",(0,i.jsx)(e.p,{children:"With path planning expertise, you're ready for:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Part V: Embodied Intelligence & VLA (Chapters 17-20)"}),"\n",(0,i.jsx)(e.li,{children:"Vision-Language-Action models"}),"\n",(0,i.jsx)(e.li,{children:"Cognitive planning and decision making"}),"\n"]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"glossary-terms",children:"Glossary Terms"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Term"}),": ",(0,i.jsx)(e.strong,{children:"Configuration Space"}),"\r\n",(0,i.jsx)(e.strong,{children:"Definition:"})," Set of all possible robot configurations, including position, orientation, and joint angles\r\n",(0,i.jsx)(e.strong,{children:"Related:"})," ",(0,i.jsx)(e.strong,{children:"Degrees of Freedom"}),", ",(0,i.jsx)(e.strong,{children:"Configuration Obstacles"})]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Term"}),": ",(0,i.jsx)(e.strong,{children:"Minkowski Sum"}),"\r\n",(0,i.jsx)(e.strong,{children:"Definition:"})," Mathematical operation that computes the configuration space obstacle by expanding obstacles by robot shape\r\n",(0,i.jsx)(e.strong,{children:"Related:"})," ",(0,i.jsx)(e.strong,{children:"Configuration Space"}),", ",(0,i.jsx)(e.strong,{children:"Collision Detection"})]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Term"}),": ",(0,i.jsx)(e.strong,{children:"Heuristic Function"}),"\r\n",(0,i.jsx)(e.strong,{children:"Definition:"})," Admissible estimate of cost from current state to goal in A* algorithm\r\n",(0,i.jsx)(e.strong,{children:"Related:"})," ",(0,i.jsx)(e.strong,{children:"Admissibility"}),", ",(0,i.jsx)(e.strong,{children:"Consistency"})]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Term"}),": ",(0,i.jsx)(e.strong,{children:"Rapidly-exploring Random Tree (RRT)"}),"\r\n",(0,i.jsx)(e.strong,{children:"Definition:"})," Sampling-based planning algorithm that explores configuration space using random sampling and tree growth\r\n",(0,i.jsx)(e.strong,{children:"Related:"})," ",(0,i.jsx)(e.strong,{children:"Probabilistic Roadmap"}),", ",(0,i.jsx)(e.strong,{children:"RRT"}),"*"]}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.strong,{children:"Term"}),": ",(0,i.jsx)(e.strong,{children:"Potential Field"}),"\r\n",(0,i.jsx)(e.strong,{children:"Definition:"})," Gradient-based navigation method where obstacles exert repulsive forces and goal attracts robot\r\n",(0,i.jsx)(e.strong,{children:"Related:"})," ",(0,i.jsx)(e.strong,{children:"Artificial Potential Fields"}),", ",(0,i.jsx)(e.strong,{children:"Navigation Functions"})]}),"\n",(0,i.jsx)(e.hr,{}),"\n",(0,i.jsx)(e.h2,{id:"exercises",children:"Exercises"}),"\n",(0,i.jsx)(e.h3,{id:"exercise-161-a-implementation",children:"Exercise 16.1: A* Implementation"}),"\n",(0,i.jsx)(e.p,{children:"Implement complete A* path planner:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Create configurable heuristic functions"}),"\n",(0,i.jsx)(e.li,{children:"Add diagonal movements with appropriate costs"}),"\n",(0,i.jsx)(e.li,{children:"Implement path smoothing"}),"\n",(0,i.jsx)(e.li,{children:"Compare performance with different heuristics"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-162-rrt-planning",children:"Exercise 16.2: RRT* Planning"}),"\n",(0,i.jsx)(e.p,{children:"Build RRT* planner with rewiring:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement efficient nearest neighbor search"}),"\n",(0,i.jsx)(e.li,{children:"Add dynamic rewiring for path optimality"}),"\n",(0,i.jsx)(e.li,{children:"Compare with basic RRT performance"}),"\n",(0,i.jsx)(e.li,{children:"Handle dynamic obstacles"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-83-trajectory-optimization",children:"Exercise 8.3: Trajectory Optimization"}),"\n",(0,i.jsx)(e.p,{children:"Create trajectory optimization system:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement CHOMP for path smoothing"}),"\n",(0,i.jsx)(e.li,{children:"Add velocity and acceleration constraints"}),"\n",(0,i.jsx)(e.li,{children:"Optimize for minimum-time trajectories"}),"\n",(0,i.jsx)(e.li,{children:"Visualize optimization process"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-164-multi-robot-planning",children:"Exercise 16.4: Multi-Robot Planning"}),"\n",(0,i.jsx)(e.p,{children:"Design multi-robot path planning:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Coordinate multiple robot movements"}),"\n",(0,i.jsx)(e.li,{children:"Implement conflict detection and resolution"}),"\n",(0,i.jsx)(e.li,{children:"Add priority-based planning"}),"\n",(0,i.jsx)(e.li,{children:"Simulate multi-robot scenarios"}),"\n"]}),"\n",(0,i.jsx)(e.h3,{id:"exercise-165-dynamic-environment",children:"Exercise 16.5: Dynamic Environment"}),"\n",(0,i.jsx)(e.p,{children:"Adapt planning for dynamic environments:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Implement dynamic obstacle detection"}),"\n",(0,i.jsx)(e.li,{children:"Create re-planning strategies"}),"\n",(0,i.jsx)(e.li,{children:"Handle moving obstacles and goals"}),"\n",(0,i.jsx)(e.li,{children:"Evaluate system responsiveness"}),"\n"]})]})}function p(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(c,{...n})}):c(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>a,x:()=>o});var t=r(6540);const i={},s=t.createContext(i);function a(n){const e=t.useContext(s);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),t.createElement(s.Provider,{value:e},n.children)}}}]);