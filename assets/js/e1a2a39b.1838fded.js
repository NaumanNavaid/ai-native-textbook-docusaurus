"use strict";(globalThis.webpackChunkai_native_textbook_docusaurus=globalThis.webpackChunkai_native_textbook_docusaurus||[]).push([[6357],{5060:(r,n,e)=>{e.r(n),e.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>m});const i=JSON.parse('{"id":"part-2-ros/chapter-6-urdf-robot-description-tf-trees","title":"URDF, Robot Description, TF Trees","description":"Introduction","source":"@site/docs/part-2-ros/chapter-6-urdf-robot-description-tf-trees.mdx","sourceDirName":"part-2-ros","slug":"/part-2-ros/chapter-6-urdf-robot-description-tf-trees","permalink":"/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-6-urdf-robot-description-tf-trees","draft":false,"unlisted":false,"editUrl":"https://github.com/NaumanNavaid/ai-native-textbook-docusaurus/tree/main/docs/part-2-ros/chapter-6-urdf-robot-description-tf-trees.mdx","tags":[],"version":"current","frontMatter":{"title":"URDF, Robot Description, TF Trees","part":2,"chapter":6,"difficulty":"intermediate","estimatedTime":60,"prerequisites":["chapter-5-nodes-topics-services-actions"],"objectives":["Master URDF (Unified Robot Description Format) modeling","Understand coordinate systems and transformations","Learn TF (Transform) tree concepts and implementation","Create complete robot models with proper kinematics"]},"sidebar":"chaptersSidebar","previous":{"title":"Nodes, Topics, Services, Actions","permalink":"/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-5-nodes-topics-services-actions"},"next":{"title":"Gazebo Physics Simulation","permalink":"/ai-native-textbook-docusaurus/docs/part-3-simulation/chapter-7-gazebo-physics-simulation"}}');var t=e(4848),o=e(8453);const a={title:"URDF, Robot Description, TF Trees",part:2,chapter:6,difficulty:"intermediate",estimatedTime:60,prerequisites:["chapter-5-nodes-topics-services-actions"],objectives:["Master URDF (Unified Robot Description Format) modeling","Understand coordinate systems and transformations","Learn TF (Transform) tree concepts and implementation","Create complete robot models with proper kinematics"]},s="Chapter 6: URDF, Robot Description, and TF Trees",l={},m=[{value:"Introduction",id:"introduction",level:2},{value:"6.1 URDF Fundamentals",id:"61-urdf-fundamentals",level:2},{value:"6.1.1 URDF Structure and Components",id:"611-urdf-structure-and-components",level:3},{value:"6.1.2 Link Elements",id:"612-link-elements",level:3},{value:"6.1.3 Joint Types",id:"613-joint-types",level:3},{value:"6.2 Complete Robot Model Example",id:"62-complete-robot-model-example",level:2},{value:"6.3 TF (Transform) System",id:"63-tf-transform-system",level:2},{value:"6.3.1 Coordinate System Fundamentals",id:"631-coordinate-system-fundamentals",level:3},{value:"6.3.2 TF Listener and Usage",id:"632-tf-listener-and-usage",level:3},{value:"6.4 Advanced URDF Features",id:"64-advanced-urdf-features",level:2},{value:"6.4.1 Xacro Macros",id:"641-xacro-macros",level:3},{value:"6.5 Kinematics and Dynamics",id:"65-kinematics-and-dynamics",level:2},{value:"6.5.1 Forward Kinematics",id:"651-forward-kinematics",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 6.1: URDF Robot Creation",id:"exercise-61-urdf-robot-creation",level:3},{value:"Exercise 6.2: TF Tree Implementation",id:"exercise-62-tf-tree-implementation",level:3},{value:"Exercise 6.3: Xacro Macro System",id:"exercise-63-xacro-macro-system",level:3},{value:"Exercise 6.4: Kinematics Implementation",id:"exercise-64-kinematics-implementation",level:3},{value:"Exercise 6.5: Complete Robot Integration",id:"exercise-65-complete-robot-integration",level:3},{value:"Glossary Terms",id:"glossary-terms",level:2}];function c(r){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...r.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-6-urdf-robot-description-and-tf-trees",children:"Chapter 6: URDF, Robot Description, and TF Trees"})}),"\n",(0,t.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(n.p,{children:"Robot description is a fundamental aspect of robotics that enables visualization, simulation, and control of robotic systems. The Unified Robot Description Format (URDF) provides a standardized way to define robot geometry, kinematics, and dynamics. Combined with the Transform (TF) library, it creates a powerful system for managing coordinate relationships in complex robotic systems. This chapter covers the complete pipeline from robot modeling to coordinate management."}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"URDF and TF form the backbone of ROS 2 robotics. Mastering these concepts is essential for anyone working with robotic systems, as they provide the foundation for everything from simulation to real-world robot control."})}),"\n",(0,t.jsx)(n.h2,{id:"61-urdf-fundamentals",children:"6.1 URDF Fundamentals"}),"\n",(0,t.jsx)(n.h3,{id:"611-urdf-structure-and-components",children:"6.1.1 URDF Structure and Components"}),"\n",(0,t.jsx)(n.p,{children:"URDF uses XML to describe robot models with links (rigid bodies) and joints (connections between links):"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagram: URDF Tree Structure"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Robot Model (root)\r\n\u251c\u2500\u2500 Link: base_link\r\n\u2502   \u251c\u2500\u2500 Visual\r\n\u2502   \u2502   \u251c\u2500\u2500 Geometry\r\n\u2502   \u2502   \u2514\u2500\u2500 Material\r\n\u2502   \u251c\u2500\u2500 Collision\r\n\u2502   \u2502   \u2514\u2500\u2500 Geometry\r\n\u2502   \u2514\u2500\u2500 Inertial\r\n\u2502       \u251c\u2500\u2500 Mass\r\n\u2502       \u2514\u2500\u2500 Inertia\r\n\u2502\r\n\u251c\u2500\u2500 Joint: base_to_chassis\r\n\u2502   \u251c\u2500\u2500 Parent: base_link\r\n\u2502   \u251c\u2500\u2500 Child: chassis_link\r\n\u2502   \u251c\u2500\u2500 Type: fixed\r\n\u2502   \u2514\u2500\u2500 Origin\r\n\u2502\r\n\u251c\u2500\u2500 Link: chassis_link\r\n\u2502   \u251c\u2500\u2500 Visual/Collision/Inertial\r\n\u2502   \u2514\u2500\u2500 ...\r\n\u2502\r\n\u251c\u2500\u2500 Joint: chassis_to_wheel_1\r\n\u2502   \u251c\u2500\u2500 Parent: chassis_link\r\n\u2502   \u251c\u2500\u2500 Child: wheel_1_link\r\n\u2502   \u251c\u2500\u2500 Type: continuous\r\n\u2502   \u2514\u2500\u2500 Axis\r\n\u2502\r\n\u2514\u2500\u2500 Link: wheel_1_link\r\n    \u2514\u2500\u2500 Visual/Collision/Inertial\n"})}),"\n",(0,t.jsx)(n.h3,{id:"612-link-elements",children:"6.1.2 Link Elements"}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Visual Elements"}),"\r\nDefine how the link appears visually:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: URDF Visual Element"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml<visual",metastring:'name="chassis_visual">',children:'  \x3c!-- Origin of visual element relative to link origin --\x3e\r\n  <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n  \x3c!-- Geometric shape --\x3e\r\n  <geometry>\r\n    <box size="1.0 0.5 0.2"/>\r\n    \x3c!-- Alternative geometries:\r\n    <cylinder radius="0.1" length="0.5"/>\r\n    <sphere radius="0.2"/>\r\n    <mesh filename="package://my_robot/meshes/chassis.stl" scale="1 1 1"/>\r\n    --\x3e\r\n  </geometry>\r\n\r\n  \x3c!-- Material properties --\x3e\r\n  <material name="blue_material">\r\n    <color rgba="0 0 1 1"/>\r\n    \x3c!-- Alternative material definitions:\r\n    <texture filename="package://my_robot/textures/chassis.png"/>\r\n    <script>\r\n      <uri>file://my_material.material</uri>\r\n      <name>Blue</name>\r\n    <\/script>\r\n    --\x3e\r\n  </material>\r\n</visual>\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Collision Elements"}),"\r\nDefine collision geometry (can be simpler than visual):"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: URDF Collision Element"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml<collision",metastring:'name="chassis_collision">',children:'  <origin xyz="0 0 0" rpy="0 0 0"/>\r\n  <geometry>\r\n    \x3c!-- Use simplified geometry for efficient collision detection --\x3e\r\n    <box size="0.95 0.45 0.18"/>\r\n  </geometry>\r\n</collision>\r\n\r\n\x3c!-- Multiple collision elements for complex shapes --\x3e\r\n<collision name="camera_collision">\r\n  <origin xyz="0.3 0 0.1" rpy="0 0 0"/>\r\n  <geometry>\r\n    <cylinder radius="0.05" length="0.1"/>\r\n  </geometry>\r\n</collision>\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Inertial Elements"}),"\r\nDefine physical properties for dynamics:"]}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: URDF Inertial Element"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml<inertial>",children:'  \x3c!-- Center of mass relative to link origin --\x3e\r\n  <origin xyz="0 0 0.05" rpy="0 0 0"/>\r\n\r\n  \x3c!-- Mass in kilograms --\x3e\r\n  <mass value="5.0"/>\r\n\r\n  \x3c!-- Inertia tensor (3x3 matrix) in kg*m^2 --\x3e\r\n  <inertia ixx="0.1" ixy="0.0" ixz="0.0"\r\n            iyy="0.1" iyz="0.0"\r\n            izz="0.2"/>\r\n</inertial>\n'})}),"\n",(0,t.jsx)(n.h3,{id:"613-joint-types",children:"6.1.3 Joint Types"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagram: URDF Joint Types"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"Revolute Joint\r\n[Link A] \u2500\u2500(\u03b8)\u2500\u2500\u2500 [Link B]\r\n- Single axis rotation\r\n- Limited range option\r\n- Continuous or limited\r\n\r\nContinuous Joint\r\n[Link A] \u2500\u2500(\u221e)\u2500\u2500\u2500 [Link B]\r\n- Unlimited rotation\r\n- Single axis\r\n- Example: Wheels\r\n\r\nPrismatic Joint\r\n[Link A] \u2500\u2500\u2195\u2500\u2500\u2500 [Link B]\r\n- Linear motion\r\n- Single axis\r\n- Limited range\r\n\r\nFixed Joint\r\n[Link A] \u2500\u2500\u2297\u2500\u2500\u2500 [Link B]\r\n- No relative motion\r\n- Rigid connection\r\n- Base to ground\r\n\r\nFloating Joint\r\n[Link A] \u2500\u2500(6DOF)\u2500\u2500\u2500 [Link B]\r\n- 6 degrees of freedom\r\n- Free motion\r\n- Flying objects\r\n\r\nPlanar Joint\r\n[Link A] \u2500\u2500(3DOF)\u2500\u2500\u2500 [Link B]\r\n- X, Y, Yaw motion\r\n- Ground robots\r\n- 2D navigation\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: URDF Joint Examples"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml\x3c!--",metastring:"Revolute joint with limits --\x3e",children:'<joint name="elbow_joint" type="revolute">\r\n  <parent link="upper_arm_link"/>\r\n  <child link="forearm_link"/>\r\n  <origin xyz="0 0 0.3" rpy="0 0 0"/>\r\n  <axis xyz="0 1 0"/>\r\n  <limit lower="-2.356" upper="2.356" effort="30.0" velocity="1.0"/>\r\n</joint>\r\n\r\n\x3c!-- Continuous joint for wheels --\x3e\r\n<joint name="wheel_1_joint" type="continuous">\r\n  <parent link="base_link"/>\r\n  <child link="wheel_1_link"/>\r\n  <origin xyz="0.2 0.2 -0.1" rpy="1.5708 0 0"/>\r\n  <axis xyz="0 0 1"/>\r\n</joint>\r\n\r\n\x3c!-- Prismatic joint for linear actuator --\x3e\r\n<joint name="linear_joint" type="prismatic">\r\n  <parent link="base_link"/>\r\n  <child link="slider_link"/>\r\n  <origin xyz="0 0 0" rpy="0 0 0"/>\r\n  <axis xyz="0 0 1"/>\r\n  <limit lower="0.0" upper="0.5" effort="100.0" velocity="0.1"/>\r\n</joint>\r\n\r\n\x3c!-- Fixed joint for rigid connection --\x3e\r\n<joint name="camera_joint" type="fixed">\r\n  <parent link="base_link"/>\r\n  <child link="camera_link"/>\r\n  <origin xyz="0.3 0 0.2" rpy="0 0.2"/>\r\n</joint>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"62-complete-robot-model-example",children:"6.2 Complete Robot Model Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml",metastring:'title="Complete Mobile Robot URDF"',children:'<?xml version="1.0"?>\r\n<robot name="mobile_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n\r\n  \x3c!-- Define materials --\x3e\r\n  <material name="blue">\r\n    <color rgba="0 0 1 1"/>\r\n  </material>\r\n\r\n  <material name="black">\r\n    <color rgba="0 0 0 1"/>\r\n  </material>\r\n\r\n  <material name="red">\r\n    <color rgba="1 0 0 1"/>\r\n  </material>\r\n\r\n  \x3c!-- Base link (robot footprint) --\x3e\r\n  <link name="base_footprint">\r\n    \x3c!-- Used for ground contact --\x3e\r\n  </link>\r\n\r\n  \x3c!-- Base link (main chassis) --\x3e\r\n  <link name="base_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    \x3c!-- Visual representation --\x3e\r\n    <visual>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.4 0.3 0.2"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n\r\n    \x3c!-- Collision geometry --\x3e\r\n    <collision>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.4 0.3 0.2"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    \x3c!-- Inertial properties --\x3e\r\n    <inertial>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <mass value="5.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0"\r\n                iyy="0.1" iyz="0.0"\r\n                izz="0.2"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  \x3c!-- Joint connecting base to footprint --\x3e\r\n  <joint name="base_footprint_joint" type="fixed">\r\n    <parent link="base_footprint"/>\r\n    <child link="base_link"/>\r\n    <origin xyz="0 0 0.05" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Left wheel --\x3e\r\n  <link name="left_wheel_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.1" length="0.05"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.1" length="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0"\r\n                iyy="0.01" iyz="0.0"\r\n                izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="left_wheel_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="left_wheel_link"/>\r\n    <origin xyz="-0.05 0.175 -0.05" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Right wheel --\x3e\r\n  <link name="right_wheel_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.1" length="0.05"/>\r\n      </geometry>\r\n      <material name="black"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="1.5708 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.1" length="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="0.5"/>\r\n      <inertia ixx="0.01" ixy="0.0" ixz="0.0"\r\n                iyy="0.01" iyz="0.0"\r\n                izz="0.01"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="right_wheel_joint" type="continuous">\r\n    <parent link="base_link"/>\r\n    <child link="right_wheel_link"/>\r\n    <origin xyz="-0.05 -0.175 -0.05" rpy="0 0 0"/>\r\n    <axis xyz="0 1 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Caster wheel --\x3e\r\n  <link name="caster_wheel_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="0.05"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <sphere radius="0.05"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="0.3"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0"\r\n                iyy="0.001" iyz="0.0"\r\n                izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="caster_wheel_joint" type="sphere">\r\n    <parent link="base_link"/>\r\n    <child link="caster_wheel_link"/>\r\n    <origin xyz="0.15 0 -0.05" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Camera --\x3e\r\n  <link name="camera_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.05 0.05 0.05"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="0.05 0.05 0.05"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="0.1"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0"\r\n                iyy="0.001" iyz="0.0"\r\n                izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="camera_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="camera_link"/>\r\n    <origin xyz="0.2 0 0.15" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- LiDAR --\x3e\r\n  <link name="laser_link">\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.1"/>\r\n      </geometry>\r\n      <material name="red"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <geometry>\r\n        <cylinder radius="0.05" length="0.1"/>\r\n      </geometry>\r\n    </collision>\r\n\r\n    <inertial>\r\n      <origin xyz="0 0 0" rpy="0 0 0"/>\r\n      <mass value="0.2"/>\r\n      <inertia ixx="0.001" ixy="0.0" ixz="0.0"\r\n                iyy="0.001" iyz="0.0"\r\n                izz="0.001"/>\r\n    </inertial>\r\n  </link>\r\n\r\n  <joint name="laser_joint" type="fixed">\r\n    <parent link="base_link"/>\r\n    <child link="laser_link"/>\r\n    <origin xyz="0 0 0.25" rpy="0 0 0"/>\r\n  </joint>\r\n\r\n  \x3c!-- Gazebo specific settings --\x3e\r\n  <gazebo reference="left_wheel_link">\r\n    <material>Gazebo/Black</material>\r\n    <mu1>1.0</mu1>\r\n    <mu2>1.0</mu2>\r\n    <kp>1000000.0</kp>\r\n    <kd>1.0</kd>\r\n    <minDepth>0.001</minDepth>\r\n    <maxVel>1.0</maxVel>\r\n  </gazebo>\r\n\r\n  <gazebo reference="right_wheel_link">\r\n    <material>Gazebo/Black</material>\r\n    <mu1>1.0</mu1>\r\n    <mu2>1.0</mu2>\r\n    <kp>1000000.0</kp>\r\n    <kd>1.0</kd>\r\n    <minDepth>0.001</minDepth>\r\n    <maxVel>1.0</maxVel>\r\n  </gazebo>\r\n\r\n</robot>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"63-tf-transform-system",children:"6.3 TF (Transform) System"}),"\n",(0,t.jsx)(n.h3,{id:"631-coordinate-system-fundamentals",children:"6.3.1 Coordinate System Fundamentals"}),"\n",(0,t.jsx)(n.p,{children:"The TF system manages coordinate relationships between different parts of a robot:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Diagram: TF Tree for Mobile Robot"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"map\r\n  \u2514\u2500 odom\r\n     \u2514\u2500 base_footprint\r\n        \u2514\u2500 base_link\r\n           \u251c\u2500 left_wheel_link\r\n           \u251c\u2500 right_wheel_link\r\n           \u251c\u2500 caster_wheel_link\r\n           \u251c\u2500 camera_link\r\n           \u2502  \u2514\u2500 camera_optical_link\r\n           \u2514\u2500 laser_link\n"})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: TF Publisher Example"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-pythonimport",metastring:"rclpy",children:'from rclpy.node import Node\r\nimport tf2_ros\r\nimport tf_transformations\r\nfrom geometry_msgs.msg import TransformStamped\r\nfrom nav_msgs.msg import Odometry\r\n\r\nclass TFPublisher(Node):\r\n    def __init__(self):\r\n        super().__init__(\'tf_publisher\')\r\n\r\n        # TF broadcaster\r\n        self.tf_broadcaster = tf2_ros.TransformBroadcaster(self)\r\n\r\n        # TF static broadcaster\r\n        self.static_tf_broadcaster = tf2_ros.StaticTransformBroadcaster(self)\r\n\r\n        # Publish static transforms\r\n        self.publish_static_transforms()\r\n\r\n        # Subscribe to odometry\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, \'/odom\', self.odom_callback, 10)\r\n\r\n        # Timer for periodic transforms\r\n        self.timer = self.create_timer(0.05, self.publish_periodic_transforms)\r\n\r\n        self.get_logger().info(\'TF publisher initialized\')\r\n\r\n    def publish_static_transforms(self):\r\n        """Publish static transforms that don\'t change"""\r\n        transforms = []\r\n\r\n        # Camera to optical frame\r\n        camera_to_optical = TransformStamped()\r\n        camera_to_optical.header.stamp = self.get_clock().now().to_msg()\r\n        camera_to_optical.header.frame_id = "camera_link"\r\n        camera_to_optical.child_frame_id = "camera_optical_link"\r\n\r\n        camera_to_optical.transform.translation.x = 0.0\r\n        camera_to_optical.transform.translation.y = 0.0\r\n        camera_to_optical.transform.translation.z = 0.0\r\n\r\n        # Camera optical frame typically has different axis convention\r\n        # X right, Y down, Z forward\r\n        q = tf_transformations.quaternion_from_euler(-1.5708, 0, -1.5708)\r\n        camera_to_optical.transform.rotation.x = q[0]\r\n        camera_to_optical.transform.rotation.y = q[1]\r\n        camera_to_optical.transform.rotation.z = q[2]\r\n        camera_to_optical.transform.rotation.w = q[3]\r\n\r\n        transforms.append(camera_to_optical)\r\n\r\n        # Base footprint to base link\r\n        footprint_to_base = TransformStamped()\r\n        footprint_to_base.header.stamp = self.get_clock().now().to_msg()\r\n        footprint_to_base.header.frame_id = "base_footprint"\r\n        footprint_to_base.child_frame_id = "base_link"\r\n\r\n        footprint_to_base.transform.translation.x = 0.0\r\n        footprint_to_base.transform.translation.y = 0.0\r\n        footprint_to_base.transform.translation.z = 0.05\r\n\r\n        q = tf_transformations.quaternion_from_euler(0, 0, 0)\r\n        footprint_to_base.transform.rotation.x = q[0]\r\n        footprint_to_base.transform.rotation.y = q[1]\r\n        footprint_to_base.transform.rotation.z = q[2]\r\n        footprint_to_base.transform.rotation.w = q[3]\r\n\r\n        transforms.append(footprint_to_base)\r\n\r\n        # Send static transforms\r\n        self.static_tf_broadcaster.sendTransform(transforms)\r\n\r\n    def odom_callback(self, msg):\r\n        """Publish odom to base_link transform from odometry"""\r\n        odom_to_base = TransformStamped()\r\n        odom_to_base.header = msg.header\r\n        odom_to_base.child_frame_id = msg.child_frame_id\r\n\r\n        odom_to_base.transform.translation.x = msg.pose.pose.position.x\r\n        odom_to_base.transform.translation.y = msg.pose.pose.position.y\r\n        odom_to_base.transform.translation.z = msg.pose.pose.position.z\r\n\r\n        odom_to_base.transform.rotation.x = msg.pose.pose.orientation.x\r\n        odom_to_base.transform.rotation.y = msg.pose.pose.orientation.y\r\n        odom_to_base.transform.rotation.z = msg.pose.pose.orientation.z\r\n        odom_to_base.transform.rotation.w = msg.pose.pose.orientation.w\r\n\r\n        self.tf_broadcaster.sendTransform(odom_to_base)\r\n\r\n    def publish_periodic_transforms(self):\r\n        """Publish periodic transforms (e.g., for moving joints)"""\r\n        transforms = []\r\n\r\n        # Example: Simulate joint positions\r\n        current_time = self.get_clock().now().seconds()\r\n\r\n        # Left wheel joint\r\n        left_wheel_transform = TransformStamped()\r\n        left_wheel_transform.header.stamp = self.get_clock().now().to_msg()\r\n        left_wheel_transform.header.frame_id = "base_link"\r\n        left_wheel_transform.child_frame_id = "left_wheel_link"\r\n\r\n        left_wheel_transform.transform.translation.x = -0.05\r\n        left_wheel_transform.transform.translation.y = 0.175\r\n        left_wheel_transform.transform.translation.z = -0.05\r\n\r\n        # Rotate wheel based on time (simulated motion)\r\n        wheel_angle = current_time * 2.0  # 2 rad/s\r\n        q = tf_transformations.quaternion_from_euler(wheel_angle, 0, 0)\r\n        left_wheel_transform.transform.rotation.x = q[0]\r\n        left_wheel_transform.transform.rotation.y = q[1]\r\n        left_wheel_transform.transform.rotation.z = q[2]\r\n        left_wheel_transform.transform.rotation.w = q[3]\r\n\r\n        transforms.append(left_wheel_transform)\r\n\r\n        # Right wheel joint\r\n        right_wheel_transform = TransformStamped()\r\n        right_wheel_transform.header.stamp = self.get_clock().now().to_msg()\r\n        right_wheel_transform.header.frame_id = "base_link"\r\n        right_wheel_transform.child_frame_id = "right_wheel_link"\r\n\r\n        right_wheel_transform.transform.translation.x = -0.05\r\n        right_wheel_transform.transform.translation.y = -0.175\r\n        right_wheel_transform.transform.translation.z = -0.05\r\n\r\n        q = tf_transformations.quaternion_from_euler(wheel_angle, 0, 0)\r\n        right_wheel_transform.transform.rotation.x = q[0]\r\n        right_wheel_transform.transform.rotation.y = q[1]\r\n        right_wheel_transform.transform.rotation.z = q[2]\r\n        right_wheel_transform.transform.rotation.w = q[3]\r\n\r\n        transforms.append(right_wheel_transform)\r\n\r\n        # Send transforms\r\n        self.tf_broadcaster.sendTransform(transforms)\n'})}),"\n",(0,t.jsx)(n.h3,{id:"632-tf-listener-and-usage",children:"6.3.2 TF Listener and Usage"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: TF Listener Example"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-pythonimport",metastring:"rclpy",children:"from rclpy.node import Node\r\nimport tf2_ros\r\nimport tf2_geometry_msgs\r\nfrom geometry_msgs.msg import PointStamped\r\nfrom sensor_msgs.msg import LaserScan\r\n\r\nclass TFListener(Node):\r\n    def __init__(self):\r\n        super().__init__('tf_listener')\r\n\r\n        # TF buffer and listener\r\n        self.tf_buffer = tf2_ros.Buffer()\r\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)\r\n\r\n        # Subscribe to sensor data\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, '/laser/scan', self.laser_callback, 10)\r\n\r\n        # Publisher for transformed data\r\n        self.transformed_point_pub = self.create_publisher(\r\n            PointStamped, '/transformed_point', 10)\r\n\r\n        self.get_logger().info('TF listener initialized')\r\n\r\n    def laser_callback(self, msg):\r\n        \"\"\"Transform LiDAR data and process\"\"\"\r\n        # Create point in laser frame\r\n        laser_point = PointStamped()\r\n        laser_point.header = msg.header\r\n        laser_point.point.x = 1.0  # Point 1m in front of laser\r\n        laser_point.point.y = 0.0\r\n        laser_point.point.z = 0.0\r\n\r\n        try:\r\n            # Transform point from laser frame to base_link frame\r\n            base_point = self.tf_buffer.transform(\r\n                laser_point, 'base_link', timeout=rclpy.duration.Duration(seconds=1.0))\r\n\r\n            # Publish transformed point\r\n            self.transformed_point_pub.publish(base_point)\r\n\r\n            self.get_logger().info(\r\n                f'Transformed point: laser_frame ({laser_point.point.x:.2f}, {laser_point.point.y:.2f}) '\r\n                f'-> base_link ({base_point.point.x:.2f}, {base_point.point.y:.2f})')\r\n\r\n        except tf2_ros.TransformException as ex:\r\n            self.get_logger().warn(f'Transform failed: {ex}')\r\n\r\n    def lookup_transform_example(self):\r\n        \"\"\"Example of looking up transform\"\"\"\r\n        try:\r\n            # Get transform from base_link to camera_link\r\n            transform = self.tf_buffer.lookup_transform(\r\n                'base_link', 'camera_link',\r\n                rclpy.time.Time(),\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n\r\n            self.get_logger().info(\r\n                f'Transform base_link -> camera_link:\\n'\r\n                f'Translation: [{transform.transform.translation.x:.3f}, '\r\n                f'{transform.transform.translation.y:.3f}, '\r\n                f'{transform.transform.translation.z:.3f}]\\n'\r\n                f'Rotation: [{transform.transform.rotation.x:.3f}, '\r\n                f'{transform.transform.rotation.y:.3f}, '\r\n                f'{transform.transform.rotation.z:.3f}, '\r\n                f'{transform.transform.rotation.w:.3f}]')\r\n\r\n        except tf2_ros.TransformException as ex:\r\n            self.get_logger().warn(f'Lookup transform failed: {ex}')\r\n\r\n    def get_robot_pose_in_map(self):\r\n        \"\"\"Get robot pose in map frame\"\"\"\r\n        try:\r\n            # Get transform from map to base_link\r\n            map_to_base = self.tf_buffer.lookup_transform(\r\n                'map', 'base_link',\r\n                rclpy.time.Time(),\r\n                timeout=rclpy.duration.Duration(seconds=1.0))\r\n\r\n            # Extract pose\r\n            x = map_to_base.transform.translation.x\r\n            y = map_to_base.transform.translation.y\r\n            z = map_to_base.transform.translation.z\r\n\r\n            # Convert quaternion to euler angles\r\n            import tf_transformations\r\n            q = [\r\n                map_to_base.transform.rotation.x,\r\n                map_to_base.transform.rotation.y,\r\n                map_to_base.transform.rotation.z,\r\n                map_to_base.transform.rotation.w\r\n            ]\r\n            roll, pitch, yaw = tf_transformations.euler_from_quaternion(q)\r\n\r\n            self.get_logger().info(\r\n                f'Robot pose in map: x={x:.2f}, y={y:.2f}, yaw={yaw:.2f}')\r\n\r\n            return {\r\n                'x': x, 'y': y, 'z': z,\r\n                'roll': roll, 'pitch': pitch, 'yaw': yaw\r\n            }\r\n\r\n        except tf2_ros.TransformException as ex:\r\n            self.get_logger().warn(f'Get robot pose failed: {ex}')\r\n            return None\r\n\r\n# Advanced TF operations\r\nclass AdvancedTFOperations(Node):\r\n    def __init__(self):\r\n        super().__init__('advanced_tf_operations')\r\n\r\n        self.tf_buffer = tf2_ros.Buffer()\r\n        self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)\r\n\r\n    def calculate_relative_pose(self, frame1, frame2, common_frame='base_link'):\r\n        \"\"\"Calculate relative pose between two frames\"\"\"\r\n        try:\r\n            # Get transform from common_frame to frame1\r\n            common_to_1 = self.tf_buffer.lookup_transform(\r\n                common_frame, frame1, rclpy.time.Time())\r\n\r\n            # Get transform from common_frame to frame2\r\n            common_to_2 = self.tf_buffer.lookup_transform(\r\n                common_frame, frame2, rclpy.time.Time())\r\n\r\n            # Calculate relative transform\r\n            # frame1 -> frame2 = (common_to_1)^-1 * common_to_2\r\n\r\n            # This would require matrix operations in a real implementation\r\n            # For simplicity, we'll just return the transforms\r\n            return common_to_1, common_to_2\r\n\r\n        except tf2_ros.TransformException as ex:\r\n            self.get_logger().error(f'Relative pose calculation failed: {ex}')\r\n            return None, None\r\n\r\n    def transform_path(self, points, source_frame, target_frame):\r\n        \"\"\"Transform a path of points from source to target frame\"\"\"\r\n        transformed_points = []\r\n\r\n        for point in points:\r\n            point_stamped = PointStamped()\r\n            point_stamped.header.stamp = self.get_clock().now().to_msg()\r\n            point_stamped.header.frame_id = source_frame\r\n            point_stamped.point.x = point[0]\r\n            point_stamped.point.y = point[1]\r\n            point_stamped.point.z = point[2]\r\n\r\n            try:\r\n                transformed = self.tf_buffer.transform(\r\n                    point_stamped, target_frame,\r\n                    timeout=rclpy.duration.Duration(seconds=0.1))\r\n\r\n                transformed_points.append([\r\n                    transformed.point.x,\r\n                    transformed.point.y,\r\n                    transformed.point.z\r\n                ])\r\n\r\n            except tf2_ros.TransformException as ex:\r\n                self.get_logger().warn(f'Point transform failed: {ex}')\r\n\r\n        return transformed_points\n"})}),"\n",(0,t.jsx)(n.h2,{id:"64-advanced-urdf-features",children:"6.4 Advanced URDF Features"}),"\n",(0,t.jsx)(n.h3,{id:"641-xacro-macros",children:"6.4.1 Xacro Macros"}),"\n",(0,t.jsx)(n.p,{children:"Xacro (XML Macros) enables reusable URDF components:"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: Xacro Macro for Wheel"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml<?xml",metastring:'version="1.0"?>',children:'<robot xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n\r\n  \x3c!-- Wheel macro --\x3e\r\n  <xacro:macro name="wheel" params="prefix parent side mass:=0.5 radius:=0.1 length:=0.05">\r\n    <link name="${prefix}_wheel_${side}_link">\r\n      <inertial>\r\n        <origin xyz="0 0 0" rpy="0 0 0"/>\r\n        <mass value="${mass}"/>\r\n        <inertia ixx="${mass*(3*radius*radius+length*length)/12}"\r\n                  ixy="0" ixz="0"\r\n                  iyy="${mass*3*radius*radius/12}"\r\n                  iyz="0"\r\n                  izz="${mass*(3*radius*radius+length*length)/12}"/>\r\n      </inertial>\r\n\r\n      <visual>\r\n        <origin xyz="0 0 0" rpy="${\'$\'}{pi/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${radius}" length="${length}"/>\r\n        </geometry>\r\n        <material name="black"/>\r\n      </visual>\r\n\r\n      <collision>\r\n        <origin xyz="0 0 0" rpy="${\'$\'}{pi/2} 0 0"/>\r\n        <geometry>\r\n          <cylinder radius="${radius}" length="${length}"/>\r\n        </geometry>\r\n      </collision>\r\n    </link>\r\n\r\n    <joint name="${prefix}_wheel_${side}_joint" type="continuous">\r\n      <parent link="${parent}"/>\r\n      <child link="${prefix}_wheel_${side}_link"/>\r\n      <xacro:if value="${side == \'left\'}">\r\n        <origin xyz="-0.05 0.175 -0.05" rpy="0 0 0"/>\r\n      </xacro:if>\r\n      <xacro:if value="${side == \'right\'}">\r\n        <origin xyz="-0.05 -0.175 -0.05" rpy="0 0 0"/>\r\n      </xacro:if>\r\n      <axis xyz="0 1 0"/>\r\n    </joint>\r\n\r\n    <gazebo reference="${prefix}_wheel_${side}_link">\r\n      <material>Gazebo/Black</material>\r\n      <mu1>1.0</mu1>\r\n      <mu2>1.0</mu2>\r\n      <kp>1000000.0</kp>\r\n      <kd>1.0</kd>\r\n      <minDepth>0.001</minDepth>\r\n      <maxVel>1.0</maxVel>\r\n    </gazebo>\r\n  </xacro:macro>\r\n\r\n  \x3c!-- Sensor macro --\x3e\r\n  <xacro:macro name="sensor" params="prefix parent x y z r p y">\r\n    <link name="${prefix}_link">\r\n      <inertial>\r\n        <origin xyz="0 0 0" rpy="0 0 0"/>\r\n        <mass value="0.1"/>\r\n        <inertia ixx="0.001" ixy="0.0" ixz="0.0"\r\n                  iyy="0.001" iyz="0.0"\r\n                  izz="0.001"/>\r\n      </inertial>\r\n\r\n      <visual>\r\n        <origin xyz="0 0 0" rpy="0 0 0"/>\r\n        <geometry>\r\n          <box size="0.05 0.05 0.05"/>\r\n        </geometry>\r\n        <material name="blue"/>\r\n      </visual>\r\n\r\n      <collision>\r\n        <origin xyz="0 0 0" rpy="0 0 0"/>\r\n        <geometry>\r\n          <box size="0.05 0.05 0.05"/>\r\n        </geometry>\r\n      </collision>\r\n    </link>\r\n\r\n    <joint name="${prefix}_joint" type="fixed">\r\n      <parent link="${parent}"/>\r\n      <child link="${prefix}_link"/>\r\n      <origin xyz="${\'$\'}{x} ${\'$\'}{y} ${\'$\'}{z}" rpy="${\'$\'}{r} ${\'$\'}{p} ${\'$\'}{y}"/>\r\n    </joint>\r\n  </xacro:macro>\r\n\r\n</robot>\n'})}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: Main Robot Xacro File"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-xml<?xml",metastring:'version="1.0"?>',children:'<robot name="xacro_robot" xmlns:xacro="http://www.ros.org/wiki/xacro">\r\n\r\n  \x3c!-- Include macro files --\x3e\r\n  <xacro:include filename="$(find my_robot)/urdf/macros.xacro"/>\r\n\r\n  \x3c!-- Define properties --\x3e\r\n  <xacro:property name="wheel_radius" value="0.1"/>\r\n  <xacro:property name="wheel_mass" value="0.5"/>\r\n  <xacro:property name="robot_width" value="0.4"/>\r\n  <xacro:property name="robot_length" value="0.5"/>\r\n\r\n  \x3c!-- Base link --\x3e\r\n  <link name="base_link">\r\n    <inertial>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <mass value="5.0"/>\r\n      <inertia ixx="0.1" ixy="0.0" ixz="0.0"\r\n                iyy="0.1" iyz="0.0"\r\n                izz="0.2"/>\r\n    </inertial>\r\n\r\n    <visual>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${robot_length} ${robot_width} 0.2"/>\r\n      </geometry>\r\n      <material name="blue"/>\r\n    </visual>\r\n\r\n    <collision>\r\n      <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n      <geometry>\r\n        <box size="${robot_length} ${robot_width} 0.2"/>\r\n      </geometry>\r\n    </collision>\r\n  </link>\r\n\r\n  \x3c!-- Use wheel macro --\x3e\r\n  <xacro:wheel prefix="front" parent="base_link" side="left"\r\n               mass="${wheel_mass}" radius="${wheel_radius}"/>\r\n  <xacro:wheel prefix="front" parent="base_link" side="right"\r\n               mass="${wheel_mass}" radius="${wheel_radius}"/>\r\n  <xacro:wheel prefix="rear" parent="base_link" side="left"\r\n               mass="${wheel_mass}" radius="${wheel_radius}"/>\r\n  <xacro:wheel prefix="rear" parent="base_link" side="right"\r\n               mass="${wheel_mass}" radius="${wheel_radius}"/>\r\n\r\n  \x3c!-- Use sensor macro --\x3e\r\n  <xacro:sensor prefix="camera" parent="base_link"\r\n                 x="${robot_length/2}" y="0" z="0.15" r="0" p="0" y="0"/>\r\n  <xacro:sensor prefix="laser" parent="base_link"\r\n                 x="0" y="0" z="0.25" r="0" p="0" y="0"/>\r\n\r\n</robot>\n'})}),"\n",(0,t.jsx)(n.h2,{id:"65-kinematics-and-dynamics",children:"6.5 Kinematics and Dynamics"}),"\n",(0,t.jsx)(n.h3,{id:"651-forward-kinematics",children:"6.5.1 Forward Kinematics"}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Example: Forward Kinematics Implementation"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-pythonimport",metastring:"numpy as np",children:'import tf2_ros\r\nfrom geometry_msgs.msg import TransformStamped\r\n\r\nclass RobotKinematics:\r\n    def __init__(self):\r\n        # Robot configuration (example 6-DOF arm)\r\n        self.joint_names = [\'joint1\', \'joint2\', \'joint3\', \'joint4\', \'joint5\', \'joint6\']\r\n\r\n        # DH parameters for a simple 6-DOF arm\r\n        # a (link length), alpha (link twist), d (link offset), theta (joint angle)\r\n        self.dh_parameters = [\r\n            [0.0,  np.pi/2,  0.2,    0.0],    # Joint 1\r\n            [0.4,  0.0,      0.0,    0.0],    # Joint 2\r\n            [0.3,  0.0,      0.0,    0.0],    # Joint 3\r\n            [0.0,  np.pi/2,  0.0,    0.0],    # Joint 4\r\n            [0.0,  -np.pi/2, 0.15,   0.0],    # Joint 5\r\n            [0.0,  0.0,      0.0,    0.0]     # Joint 6\r\n        ]\r\n\r\n        self.joint_positions = [0.0] * 6\r\n\r\n    def dh_transform(self, a, alpha, d, theta):\r\n        """Create DH transformation matrix"""\r\n        ct = np.cos(theta)\r\n        st = np.sin(theta)\r\n        ca = np.cos(alpha)\r\n        sa = np.sin(alpha)\r\n\r\n        T = np.array([\r\n            [ct,      -st*ca,   st*sa,    a*ct],\r\n            [st,       ct*ca,  -ct*sa,    a*st],\r\n            [0.0,      sa,      ca,       d],\r\n            [0.0,      0.0,     0.0,      1.0]\r\n        ])\r\n\r\n        return T\r\n\r\n    def forward_kinematics(self, joint_angles=None):\r\n        """Calculate forward kinematics"""\r\n        if joint_angles is None:\r\n            joint_angles = self.joint_positions\r\n\r\n        # Start with identity matrix\r\n        T = np.eye(4)\r\n\r\n        # Apply DH transformations\r\n        for i, angle in enumerate(joint_angles):\r\n            a, alpha, d, _ = self.dh_parameters[i]\r\n            T_i = self.dh_transform(a, alpha, d, angle + self.dh_parameters[i][3])\r\n            T = T @ T_i\r\n\r\n        return T\r\n\r\n    def get_joint_positions(self):\r\n        """Get current joint positions"""\r\n        return self.joint_positions\r\n\r\n    def set_joint_position(self, joint_idx, angle):\r\n        """Set individual joint position"""\r\n        if 0 <= joint_idx < len(self.joint_positions):\r\n            self.joint_positions[joint_idx] = angle\r\n\r\n    def set_joint_positions(self, angles):\r\n        """Set all joint positions"""\r\n        self.joint_positions = angles[:len(self.joint_positions)]\r\n\r\n    def get_end_effector_pose(self):\r\n        """Get end-effector pose in homogeneous transform"""\r\n        T = self.forward_kinematics()\r\n\r\n        pose = {\r\n            \'position\': T[:3, 3],\r\n            \'orientation\': T[:3, :3],\r\n            \'homogeneous\': T\r\n        }\r\n\r\n        return pose\r\n\r\n    def publish_tf_tree(self, tf_broadcaster, base_frame=\'base_link\'):\r\n        """Publish TF tree for current joint positions"""\r\n        transforms = []\r\n\r\n        # Current transformation\r\n        T = np.eye(4)\r\n        parent_frame = base_frame\r\n\r\n        for i, angle in enumerate(self.joint_positions):\r\n            a, alpha, d, _ = self.dh_parameters[i]\r\n            T_i = self.dh_transform(a, alpha, d, angle + self.dh_parameters[i][3])\r\n            T = T @ T_i\r\n\r\n            # Create transform\r\n            t = TransformStamped()\r\n            t.header.stamp = self.get_clock().now().to_msg() if hasattr(self, \'get_clock\') else None\r\n            t.header.frame_id = parent_frame\r\n            t.child_frame_id = f\'link_{i+1}\'\r\n\r\n            # Extract translation\r\n            t.transform.translation.x = T[0, 3]\r\n            t.transform.translation.y = T[1, 3]\r\n            t.transform.translation.z = T[2, 3]\r\n\r\n            # Extract rotation (convert rotation matrix to quaternion)\r\n            import tf_transformations\r\n            q = tf_transformations.quaternion_from_matrix(T)\r\n            t.transform.rotation.x = q[0]\r\n            t.transform.rotation.y = q[1]\r\n            t.transform.rotation.z = q[2]\r\n            t.transform.rotation.w = q[3]\r\n\r\n            transforms.append(t)\r\n            parent_frame = f\'link_{i+1}\'\r\n\r\n        return transforms\r\n\r\n    def inverse_kinematics_simple(self, target_pose, max_iterations=100, tolerance=0.01):\r\n        """Simple inverse kinematics using iterative approach"""\r\n        current_angles = self.joint_positions.copy()\r\n\r\n        for iteration in range(max_iterations):\r\n            # Forward kinematics with current angles\r\n            T = self.forward_kinematics(current_angles)\r\n\r\n            # Calculate error\r\n            error_position = target_pose[\'position\'] - T[:3, 3]\r\n            error_magnitude = np.linalg.norm(error_position)\r\n\r\n            if error_magnitude < tolerance:\r\n                self.joint_positions = current_angles\r\n                return current_angles\r\n\r\n            # Simple gradient descent (simplified)\r\n            # In practice, use more sophisticated IK methods\r\n            learning_rate = 0.1\r\n            delta_angles = learning_rate * error_position\r\n\r\n            # Update angles (very simplified approach)\r\n            for i in range(len(current_angles)):\r\n                current_angles[i] += delta_angles[i % 3] * 0.1\r\n                # Apply joint limits if needed\r\n                current_angles[i] = np.clip(current_angles[i], -np.pi, np.pi)\r\n\r\n        # Return best effort solution\r\n        self.joint_positions = current_angles\r\n        return current_angles\r\n\r\n# Advanced kinematics with Jacobian\r\nclass AdvancedKinematics(RobotKinematics):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n    def compute_jacobian(self, joint_angles=None):\r\n        """Compute Jacobian matrix"""\r\n        if joint_angles is None:\r\n            joint_angles = self.joint_positions\r\n\r\n        J = np.zeros((6, len(joint_angles)))\r\n\r\n        # Numerical computation of Jacobian\r\n        delta = 0.0001\r\n        T_current = self.forward_kinematics(joint_angles)\r\n        p_current = T_current[:3, 3]\r\n\r\n        for i in range(len(joint_angles)):\r\n            # Perturb joint i\r\n            angles_perturbed = joint_angles.copy()\r\n            angles_perturbed[i] += delta\r\n\r\n            # Compute new pose\r\n            T_perturbed = self.forward_kinematics(angles_perturbed)\r\n            p_perturbed = T_perturbed[:3, 3]\r\n\r\n            # Approximate derivative\r\n            J[:3, i] = (p_perturbed - p_current) / delta\r\n\r\n        # Orientation part of Jacobian (simplified)\r\n        # In practice, use proper angular velocity Jacobian\r\n        J[3:6, :] = 0.1 * np.random.randn(3, len(joint_angles))\r\n\r\n        return J\r\n\r\n    def inverse_kinematics_jacobian(self, target_pose, max_iterations=100, tolerance=0.01):\r\n        """Inverse kinematics using Jacobian method"""\r\n        current_angles = self.joint_positions.copy()\r\n\r\n        for iteration in range(max_iterations):\r\n            # Forward kinematics\r\n            T = self.forward_kinematics(current_angles)\r\n\r\n            # Compute error\r\n            error_position = target_pose[\'position\'] - T[:3, 3]\r\n            error_magnitude = np.linalg.norm(error_position)\r\n\r\n            if error_magnitude < tolerance:\r\n                self.joint_positions = current_angles\r\n                return current_angles\r\n\r\n            # Compute Jacobian\r\n            J = self.compute_jacobian(current_angles)\r\n\r\n            # Compute joint angle change using pseudo-inverse\r\n            try:\r\n                J_pinv = np.linalg.pinv(J)\r\n                delta_angles = J_pinv @ np.concatenate([error_position, np.zeros(3)])\r\n\r\n                # Update angles\r\n                current_angles += delta_angles * 0.1  # Learning rate\r\n\r\n                # Apply joint limits\r\n                current_angles = np.clip(current_angles, -np.pi, np.pi)\r\n\r\n            except np.linalg.LinAlgError:\r\n                self.get_logger().error(\'Jacobian singular\')\r\n                break\r\n\r\n        self.joint_positions = current_angles\r\n        return current_angles\n'})}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter covered the complete spectrum of robot description and coordinate management in ROS 2. We explored URDF modeling, the TF system, and advanced kinematic calculations essential for robotic applications."}),"\n",(0,t.jsx)(n.p,{children:"Key takeaways:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"URDF provides standardized XML format for robot modeling"}),"\n",(0,t.jsx)(n.li,{children:"Links define physical properties (visual, collision, inertial)"}),"\n",(0,t.jsx)(n.li,{children:"Joints define relationships and motion between links"}),"\n",(0,t.jsx)(n.li,{children:"TF system manages coordinate relationships in real-time"}),"\n",(0,t.jsx)(n.li,{children:"Xacro macros enable reusable and parameterized URDF components"}),"\n",(0,t.jsx)(n.li,{children:"Forward/inverse kinematics are essential for robot control"}),"\n",(0,t.jsx)(n.li,{children:"Proper naming conventions and organization are crucial for maintainability"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(n.h3,{id:"exercise-61-urdf-robot-creation",children:"Exercise 6.1: URDF Robot Creation"}),"\n",(0,t.jsx)(n.p,{children:"Create a complete URDF model for a specific robot:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Choose a robot type (mobile robot, arm, humanoid)"}),"\n",(0,t.jsx)(n.li,{children:"Define all links with proper visual, collision, and inertial properties"}),"\n",(0,t.jsx)(n.li,{children:"Create appropriate joints with realistic limits"}),"\n",(0,t.jsx)(n.li,{children:"Include sensors and actuators"}),"\n",(0,t.jsx)(n.li,{children:"Test in RViz and Gazebo"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-62-tf-tree-implementation",children:"Exercise 6.2: TF Tree Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Implement a TF tree system:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create multiple coordinate frames"}),"\n",(0,t.jsx)(n.li,{children:"Publish static and dynamic transforms"}),"\n",(0,t.jsx)(n.li,{children:"Handle transform lookups with error management"}),"\n",(0,t.jsx)(n.li,{children:"Visualize TF tree in RViz"}),"\n",(0,t.jsx)(n.li,{children:"Test with different coordinate conversions"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-63-xacro-macro-system",children:"Exercise 6.3: Xacro Macro System"}),"\n",(0,t.jsx)(n.p,{children:"Develop a reusable Xacro system:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create macros for common components (wheels, sensors, joints)"}),"\n",(0,t.jsx)(n.li,{children:"Use properties for parameterization"}),"\n",(0,t.jsx)(n.li,{children:"Include conditional logic for different configurations"}),"\n",(0,t.jsx)(n.li,{children:"Validate generated URDF"}),"\n",(0,t.jsx)(n.li,{children:"Compare with non-xacro implementation"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-64-kinematics-implementation",children:"Exercise 6.4: Kinematics Implementation"}),"\n",(0,t.jsx)(n.p,{children:"Implement kinematics for a robot arm:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Define DH parameters for 6-DOF arm"}),"\n",(0,t.jsx)(n.li,{children:"Implement forward kinematics"}),"\n",(0,t.jsx)(n.li,{children:"Create inverse kinematics solver"}),"\n",(0,t.jsx)(n.li,{children:"Test with various target poses"}),"\n",(0,t.jsx)(n.li,{children:"Analyze computational performance"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"exercise-65-complete-robot-integration",children:"Exercise 6.5: Complete Robot Integration"}),"\n",(0,t.jsx)(n.p,{children:"Integrate all concepts in a complete system:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Create complex robot URDF with Xacro"}),"\n",(0,t.jsx)(n.li,{children:"Implement TF publishing and listening"}),"\n",(0,t.jsx)(n.li,{children:"Add kinematics calculations"}),"\n",(0,t.jsx)(n.li,{children:"Integrate with robot control"}),"\n",(0,t.jsx)(n.li,{children:"Validate with simulation and visualization"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"glossary-terms",children:"Glossary Terms"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"URDF (Unified Robot Description Format)"}),": XML format for describing robot models"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Link"}),": Rigid body in robot model with visual, collision, and inertial properties"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Joint"}),": Connection between links that defines relative motion"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"TF (Transform)"}),": System for managing coordinate relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Coordinate Frame"}),": Reference system for position and orientation"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Transform Tree"}),": Hierarchical structure of coordinate relationships"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Xacro"}),": XML macro language for creating reusable URDF components"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Forward Kinematics"}),": Computing end-effector pose from joint angles"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Inverse Kinematics"}),": Computing joint angles from desired end-effector pose"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"DH (Denavit-Hartenberg) Parameters"}),": Standardized way to describe robot linkages"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Jacobian Matrix"}),": Matrix of partial derivatives relating joint velocities to end-effector velocities"]}),"\n"]})]})}function p(r={}){const{wrapper:n}={...(0,o.R)(),...r.components};return n?(0,t.jsx)(n,{...r,children:(0,t.jsx)(c,{...r})}):c(r)}},8453:(r,n,e)=>{e.d(n,{R:()=>a,x:()=>s});var i=e(6540);const t={},o=i.createContext(t);function a(r){const n=i.useContext(o);return i.useMemo(function(){return"function"==typeof r?r(n):{...n,...r}},[n,r])}function s(r){let n;return n=r.disableParentContext?"function"==typeof r.components?r.components(t):r.components||t:a(r.components),i.createElement(o.Provider,{value:n},r.children)}}}]);