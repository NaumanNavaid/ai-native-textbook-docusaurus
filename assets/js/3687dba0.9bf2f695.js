"use strict";(globalThis.webpackChunkai_native_textbook_docusaurus=globalThis.webpackChunkai_native_textbook_docusaurus||[]).push([[3106],{4033:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>o,default:()=>_,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"part-2-ros/chapter-5-nodes-topics-services-actions","title":"Nodes, Topics, Services, Actions","description":"Introduction","source":"@site/docs/part-2-ros/chapter-5-nodes-topics-services-actions.mdx","sourceDirName":"part-2-ros","slug":"/part-2-ros/chapter-5-nodes-topics-services-actions","permalink":"/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-5-nodes-topics-services-actions","draft":false,"unlisted":false,"editUrl":"https://github.com/NaumanNavaid/ai-native-textbook-docusaurus/tree/main/docs/part-2-ros/chapter-5-nodes-topics-services-actions.mdx","tags":[],"version":"current","frontMatter":{"title":"Nodes, Topics, Services, Actions","part":2,"chapter":5,"difficulty":"intermediate","estimatedTime":55,"prerequisites":["chapter-4-ros2-fundamentals"],"objectives":["Master advanced ROS 2 communication patterns","Design robust node architectures and lifecycles","Implement effective topic, service, and action patterns","Understand best practices for real-world ROS 2 applications"]},"sidebar":"chaptersSidebar","previous":{"title":"ROS 2 Fundamentals","permalink":"/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-4-ros2-fundamentals"},"next":{"title":"URDF, Robot Description, TF Trees","permalink":"/ai-native-textbook-docusaurus/docs/part-2-ros/chapter-6-urdf-robot-description-tf-trees"}}');var t=n(4848),a=n(8453);const i={title:"Nodes, Topics, Services, Actions",part:2,chapter:5,difficulty:"intermediate",estimatedTime:55,prerequisites:["chapter-4-ros2-fundamentals"],objectives:["Master advanced ROS 2 communication patterns","Design robust node architectures and lifecycles","Implement effective topic, service, and action patterns","Understand best practices for real-world ROS 2 applications"]},o="Chapter 5: Nodes, Topics, Services, and Actions",l={},c=[{value:"Introduction",id:"introduction",level:2},{value:"5.1 Advanced Node Architectures",id:"51-advanced-node-architectures",level:2},{value:"5.1.1 Node Composition and Lifecycle",id:"511-node-composition-and-lifecycle",level:3},{value:"5.1.2 Multi-threaded Node Design",id:"512-multi-threaded-node-design",level:3},{value:"5.1.3 Node Lifecycle Management",id:"513-node-lifecycle-management",level:3},{value:"5.2 Advanced Topic Patterns",id:"52-advanced-topic-patterns",level:2},{value:"5.2.1 Bandwidth Optimization",id:"521-bandwidth-optimization",level:3},{value:"5.2.2 Message Type Design",id:"522-message-type-design",level:3},{value:"5.2.3 Topic Naming Conventions",id:"523-topic-naming-conventions",level:3},{value:"5.3 Service Design Patterns",id:"53-service-design-patterns",level:2},{value:"5.3.1 Service Chain Patterns",id:"531-service-chain-patterns",level:3},{value:"5.3.2 Error Handling in Services",id:"532-error-handling-in-services",level:3},{value:"5.4 Advanced Action Implementation",id:"54-advanced-action-implementation",level:2},{value:"5.4.1 Complex Action Workflows",id:"541-complex-action-workflows",level:3},{value:"5.4.2 Action Client with Retry and Timeout",id:"542-action-client-with-retry-and-timeout",level:3},{value:"5.5 Real-world Communication Patterns",id:"55-real-world-communication-patterns",level:2},{value:"5.5.1 Sensor Processing Pipeline",id:"551-sensor-processing-pipeline",level:3},{value:"Summary",id:"summary",level:2},{value:"Exercises",id:"exercises",level:2},{value:"Exercise 5.1: Multi-threaded Node Implementation",id:"exercise-51-multi-threaded-node-implementation",level:3},{value:"Exercise 5.2: Optimized Topic Design",id:"exercise-52-optimized-topic-design",level:3},{value:"Exercise 5.3: Robust Service Chain",id:"exercise-53-robust-service-chain",level:3},{value:"Exercise 5.4: Advanced Action Workflow",id:"exercise-54-advanced-action-workflow",level:3},{value:"Exercise 5.5: Sensor Fusion System",id:"exercise-55-sensor-fusion-system",level:3},{value:"Glossary Terms",id:"glossary-terms",level:2}];function d(e){const r={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"chapter-5-nodes-topics-services-and-actions",children:"Chapter 5: Nodes, Topics, Services, and Actions"})}),"\n",(0,t.jsx)(r.h2,{id:"introduction",children:"Introduction"}),"\n",(0,t.jsx)(r.p,{children:"While Chapter 4 introduced the fundamental concepts of ROS 2, this chapter delves deeper into the advanced communication patterns that enable complex robotic systems. We'll explore sophisticated node architectures, efficient topic design patterns, robust service implementations, and complex action workflows. Understanding these patterns is essential for building scalable, maintainable, and performant robotic applications."}),"\n",(0,t.jsx)(r.admonition,{type:"info",children:(0,t.jsx)(r.p,{children:"The choice between topics, services, and actions fundamentally impacts your system's performance, reliability, and maintainability. Mastering these communication patterns is key to becoming a proficient ROS 2 developer."})}),"\n",(0,t.jsx)(r.h2,{id:"51-advanced-node-architectures",children:"5.1 Advanced Node Architectures"}),"\n",(0,t.jsx)(r.h3,{id:"511-node-composition-and-lifecycle",children:"5.1.1 Node Composition and Lifecycle"}),"\n",(0,t.jsx)(r.p,{children:"Modern ROS 2 applications often use node composition to reduce computational overhead and improve communication efficiency:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagram: Node Composition vs Multiple Nodes"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"Traditional Multi-Node Architecture:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Sensor    \u2502  \u2502 Processor   \u2502  \u2502Controller  \u2502\r\n\u2502    Node     \u2502  \u2502    Node     \u2502  \u2502    Node     \u2502\r\n\u2502             \u2502  \u2502             \u2502  \u2502             \u2502\r\n\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502  \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502\r\n\u2502 \u2502Publisher\u2502\u2500\u2500\u253c\u2500\u2192\u2502Subscriber\u2502\u2500\u2500\u253c\u2500\u2192\u2502Subscriber\u2502 \u2502\r\n\u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502  \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n    \u2195               \u2195               \u2195\r\nNetwork transport with serialization overhead\r\n\r\nComposed Node Architecture:\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                  Composed Node                          \u2502\r\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502\r\n\u2502  \u2502   Sensor    \u2502  \u2502 Processor   \u2502  \u2502Controller  \u2502     \u2502\r\n\u2502  \u2502Component   \u2502  \u2502Component   \u2502  \u2502Component   \u2502     \u2502\r\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502\r\n\u2502                                                         \u2502\r\n\u2502  \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510   \u2502\r\n\u2502  \u2502              Shared Memory Buffer                \u2502   \u2502\r\n\u2502  \u2502           Zero-Copy Communication              \u2502   \u2502\r\n\u2502  \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Composed Node Implementation"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp#include",metastring:"<rclcpp/rclcpp.hpp>",children:'#include <std_msgs/msg/string.hpp>\r\n#include <sensor_msgs/msg/image.hpp>\r\n#include <geometry_msgs/msg/twist.hpp>\r\n\r\nclass ComposedRobotNode : public rclcpp::Node {\r\npublic:\r\n    ComposedRobotNode() : Node("composed_robot_node") {\r\n\r\n        // Create components\r\n        setup_sensor_component();\r\n        setup_processor_component();\r\n        setup_controller_component();\r\n\r\n        // Create shared data structures\r\n        shared_data_ = std::make_shared<SharedData>();\r\n\r\n        RCLCPP_INFO(this->get_logger(), "Composed robot node initialized");\r\n    }\r\n\r\nprivate:\r\n    struct SharedData {\r\n        sensor_msgs::msg::Image::SharedPtr latest_image;\r\n        geometry_msgs::msg::Twist::SharedPtr control_command;\r\n        bool processing_active = false;\r\n        std::mutex mutex;\r\n    };\r\n\r\n    std::shared_ptr<SharedData> shared_data_;\r\n\r\n    void setup_sensor_component() {\r\n        // Image subscriber\r\n        image_sub_ = this->create_subscription<sensor_msgs::msg::Image>(\r\n            "/camera/image_raw", 10,\r\n            [this](const sensor_msgs::msg::Image::SharedPtr msg) {\r\n                std::lock_guard<std::mutex> lock(shared_data_->mutex);\r\n                shared_data_->latest_image = msg;\r\n            });\r\n\r\n        // Timer for simulated sensor processing\r\n        sensor_timer_ = this->create_wall_timer(\r\n            std::chrono::milliseconds(30),\r\n            [this]() { process_sensor_data(); });\r\n    }\r\n\r\n    void setup_processor_component() {\r\n        // Timer for image processing\r\n        processor_timer_ = this->create_wall_timer(\r\n            std::chrono::milliseconds(100),\r\n            [this]() { process_image_data(); });\r\n    }\r\n\r\n    void setup_controller_component() {\r\n        // Publisher for control commands\r\n        cmd_vel_pub_ = this->create_publisher<geometry_msgs::msg::Twist>(\r\n            "/cmd_vel", 10);\r\n\r\n        // Timer for control loop\r\n        control_timer_ = this->create_wall_timer(\r\n            std::chrono::milliseconds(50),\r\n            [this]() { execute_control_loop(); });\r\n    }\r\n\r\n    void process_sensor_data() {\r\n        // Simulate sensor processing\r\n        // In real implementation, this would process raw sensor data\r\n    }\r\n\r\n    void process_image_data() {\r\n        std::lock_guard<std::mutex> lock(shared_data_->mutex);\r\n\r\n        if (shared_data_->latest_image && !shared_data_->processing_active) {\r\n            shared_data_->processing_active = true;\r\n\r\n            // Process image (simulation)\r\n            RCLCPP_INFO(this->get_logger(),\r\n                "Processing image %dx%d",\r\n                shared_data_->latest_image->width,\r\n                shared_data_->latest_image->height);\r\n\r\n            // Generate control command based on image processing\r\n            auto cmd = std::make_shared<geometry_msgs::msg::Twist>();\r\n            cmd->linear.x = 0.5;  // Example: move forward\r\n            cmd->angular.z = 0.1;  // Example: slight turn\r\n\r\n            shared_data_->control_command = cmd;\r\n            shared_data_->processing_active = false;\r\n        }\r\n    }\r\n\r\n    void execute_control_loop() {\r\n        std::lock_guard<std::mutex> lock(shared_data_->mutex);\r\n\r\n        if (shared_data_->control_command) {\r\n            cmd_vel_pub_->publish(*shared_data_->control_command);\r\n            shared_data_->control_command.reset();\r\n        }\r\n    }\r\n\r\n    // Component members\r\n    rclcpp::Subscription<sensor_msgs::msg::Image>::SharedPtr image_sub_;\r\n    rclcpp::Publisher<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_pub_;\r\n    rclcpp::TimerBase::SharedPtr sensor_timer_;\r\n    rclcpp::TimerBase::SharedPtr processor_timer_;\r\n    rclcpp::TimerBase::SharedPtr control_timer_;\r\n};\r\n\r\nint main(int argc, char** argv) {\r\n    rclcpp::init(argc, argv);\r\n    auto node = std::make_shared<ComposedRobotNode>();\r\n    rclcpp::spin(node);\r\n    rclcpp::shutdown();\r\n    return 0;\r\n}\n'})}),"\n",(0,t.jsx)(r.h3,{id:"512-multi-threaded-node-design",children:"5.1.2 Multi-threaded Node Design"}),"\n",(0,t.jsx)(r.p,{children:"ROS 2 nodes can leverage multiple threads for concurrent processing:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Multi-threaded Node Example"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-pythonimport",metastring:"rclpy",children:'from rclpy.node import Node\r\nfrom rclpy.executors import MultiThreadedExecutor\r\nimport threading\r\nimport time\r\nfrom sensor_msgs.msg import Image\r\nfrom geometry_msgs.msg import Twist\r\n\r\nclass MultiThreadedRobotNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'multithreaded_robot_node\')\r\n\r\n        # Create executor for this node\r\n        self.executor = MultiThreadedExecutor()\r\n\r\n        # Shared state\r\n        self.image_data = None\r\n        self.processing_lock = threading.Lock()\r\n        self.control_command = None\r\n\r\n        # Setup components in separate threads\r\n        self.setup_sensor_thread()\r\n        self.setup_processor_thread()\r\n        self.setup_control_thread()\r\n\r\n        self.get_logger().info(\'Multi-threaded robot node initialized\')\r\n\r\n    def setup_sensor_thread(self):\r\n        """Setup sensor processing in separate thread"""\r\n        def sensor_worker():\r\n            # Create subscription\r\n            image_sub = self.create_subscription(\r\n                Image, \'/camera/image_raw\', self.image_callback, 10)\r\n\r\n            # Add this node to executor\r\n            self.executor.add_node(self)\r\n\r\n            # Spin in thread\r\n            self.executor.spin()\r\n\r\n        # Start thread\r\n        self.sensor_thread = threading.Thread(target=sensor_worker, daemon=True)\r\n        self.sensor_thread.start()\r\n\r\n    def setup_processor_thread(self):\r\n        """Setup image processing in separate thread"""\r\n        def processor_worker():\r\n            while rclpy.ok():\r\n                time.sleep(0.1)  # 10 Hz processing\r\n\r\n                with self.processing_lock:\r\n                    if self.image_data is not None:\r\n                        self.process_image()\r\n\r\n        self.processor_thread = threading.Thread(target=processor_worker, daemon=True)\r\n        self.processor_thread.start()\r\n\r\n    def setup_control_thread(self):\r\n        """Setup control loop in separate thread"""\r\n        def control_worker():\r\n            # Create publisher\r\n            cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n\r\n            while rclpy.ok():\r\n                time.sleep(0.05)  # 20 Hz control loop\r\n\r\n                with self.processing_lock:\r\n                    if self.control_command is not None:\r\n                        cmd_vel_pub.publish(self.control_command)\r\n                        self.control_command = None\r\n\r\n        self.control_thread = threading.Thread(target=control_worker, daemon=True)\r\n        self.control_thread.start()\r\n\r\n    def image_callback(self, msg):\r\n        """Handle incoming image messages"""\r\n        with self.processing_lock:\r\n            self.image_data = msg\r\n\r\n    def process_image(self):\r\n        """Process latest image data"""\r\n        if self.image_data is None:\r\n            return\r\n\r\n        # Simulate image processing\r\n        self.get_logger().info(\r\n            f\'Processing image: {self.image_data.width}x{self.image_data.height}\')\r\n\r\n        # Generate control command\r\n        cmd = Twist()\r\n        cmd.linear.x = 0.5\r\n        cmd.angular.z = 0.1\r\n\r\n        self.control_command = cmd\r\n        self.image_data = None\r\n\r\ndef main():\r\n    rclpy.init()\r\n    node = MultiThreadedRobotNode()\r\n\r\n    try:\r\n        # Keep main thread alive\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,t.jsx)(r.h3,{id:"513-node-lifecycle-management",children:"5.1.3 Node Lifecycle Management"}),"\n",(0,t.jsx)(r.p,{children:"ROS 2 provides a lifecycle management system for controlled startup and shutdown:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Lifecycle Node Implementation"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp#include",metastring:"<rclcpp_lifecycle/lifecycle_node.hpp>",children:'#include <lifecycle_msgs/msg/state.hpp>\r\n#include <lifecycle_msgs/msg/transition.hpp>\r\n\r\nclass LifecycleRobotNode : public rclcpp_lifecycle::LifecycleNode {\r\npublic:\r\n    explicit LifecycleRobotNode(const std::string& node_name)\r\n        : LifecycleNode(node_name) {}\r\n\r\n    using CallbackReturn =\r\n        rclcpp_lifecycle::node_interfaces::LifecycleNodeInterface::CallbackReturn;\r\n\r\n    // Lifecycle state transitions\r\n    CallbackReturn on_configure(const rclcpp_lifecycle::State&) {\r\n        // Configure hardware and resources\r\n        configure_hardware();\r\n        setup_subscribers();\r\n        setup_publishers();\r\n\r\n        RCLCPP_INFO(get_logger(), "Node configured successfully");\r\n        return CallbackReturn::SUCCESS;\r\n    }\r\n\r\n    CallbackReturn on_activate(const rclcpp_lifecycle::State&) {\r\n        // Activate publishers and start processing\r\n        activate_publishers();\r\n        start_processing();\r\n\r\n        RCLCPP_INFO(get_logger(), "Node activated successfully");\r\n        return CallbackReturn::SUCCESS;\r\n    }\r\n\r\n    CallbackReturn on_deactivate(const rclcpp_lifecycle::State&) {\r\n        // Deactivate publishers and stop processing\r\n        stop_processing();\r\n        deactivate_publishers();\r\n\r\n        RCLCPP_INFO(get_logger(), "Node deactivated successfully");\r\n        return CallbackReturn::SUCCESS;\r\n    }\r\n\r\n    CallbackReturn on_cleanup(const rclcpp_lifecycle::State&) {\r\n        // Cleanup resources\r\n        cleanup_hardware();\r\n\r\n        RCLCPP_INFO(get_logger(), "Node cleaned up successfully");\r\n        return CallbackReturn::SUCCESS;\r\n    }\r\n\r\n    CallbackReturn on_shutdown(const rclcpp_lifecycle::State&) {\r\n        // Final shutdown operations\r\n        RCLCPP_INFO(get_logger(), "Node shutting down successfully");\r\n        return CallbackReturn::SUCCESS;\r\n    }\r\n\r\nprivate:\r\n    void configure_hardware() {\r\n        // Initialize hardware components\r\n        RCLCPP_INFO(get_logger(), "Configuring hardware...");\r\n    }\r\n\r\n    void setup_subscribers() {\r\n        // Setup subscribers\r\n        RCLCPP_INFO(get_logger(), "Setting up subscribers...");\r\n    }\r\n\r\n    void setup_publishers() {\r\n        // Setup publishers (but don\'t activate yet)\r\n        cmd_vel_pub_ = create_publisher<geometry_msgs::msg::Twist>(\r\n            "/cmd_vel", rclcpp::SystemDefaultsQoS());\r\n        RCLCPP_INFO(get_logger(), "Setting up publishers...");\r\n    }\r\n\r\n    void activate_publishers() {\r\n        // Activate publishers\r\n        if (cmd_vel_pub_) {\r\n            cmd_vel_pub_->on_activate();\r\n        }\r\n        RCLCPP_INFO(get_logger(), "Activating publishers...");\r\n    }\r\n\r\n    void deactivate_publishers() {\r\n        // Deactivate publishers\r\n        if (cmd_vel_pub_) {\r\n            cmd_vel_pub_->on_deactivate();\r\n        }\r\n        RCLCPP_INFO(get_logger(), "Deactivating publishers...");\r\n    }\r\n\r\n    void start_processing() {\r\n        // Start main processing loop\r\n        processing_active_ = true;\r\n        RCLCPP_INFO(get_logger(), "Starting processing...");\r\n    }\r\n\r\n    void stop_processing() {\r\n        // Stop main processing loop\r\n        processing_active_ = false;\r\n        RCLCPP_INFO(get_logger(), "Stopping processing...");\r\n    }\r\n\r\n    void cleanup_hardware() {\r\n        // Cleanup hardware resources\r\n        RCLCPP_INFO(get_logger(), "Cleaning up hardware...");\r\n    }\r\n\r\n    rclcpp_lifecycle::LifecyclePublisher<geometry_msgs::msg::Twist>::SharedPtr cmd_vel_pub_;\r\n    bool processing_active_ = false;\r\n};\n'})}),"\n",(0,t.jsx)(r.h2,{id:"52-advanced-topic-patterns",children:"5.2 Advanced Topic Patterns"}),"\n",(0,t.jsx)(r.h3,{id:"521-bandwidth-optimization",children:"5.2.1 Bandwidth Optimization"}),"\n",(0,t.jsx)(r.p,{children:"For high-frequency data streams, optimization is crucial:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Optimized Topic Publisher"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-pythonimport",metastring:"rclpy",children:'from rclpy.node import Node\r\nfrom sensor_msgs.msg import Image\r\nimport numpy as np\r\nfrom std_msgs.msg import Header\r\n\r\nclass OptimizedImagePublisher(Node):\r\n    def __init__(self):\r\n        super().__init__(\'optimized_image_publisher\')\r\n\r\n        # Publisher with optimized QoS\r\n        self.image_pub = self.create_publisher(\r\n            Image, \'/camera/image_compressed\', 10)\r\n\r\n        # Timer for high-frequency publishing\r\n        self.timer = self.create_timer(1.0/30.0, self.publish_image)  # 30 Hz\r\n\r\n        # Image data\r\n        self.image_width = 640\r\n        self.image_height = 480\r\n        self.frame_id = 0\r\n\r\n        # Compression settings\r\n        self.compression_quality = 80\r\n        self.publish_compressed = True\r\n\r\n        self.get_logger().info(\'Optimized image publisher started\')\r\n\r\n    def generate_test_image(self):\r\n        """Generate test image data"""\r\n        # Create numpy array representing image\r\n        image_data = np.random.randint(\r\n            0, 256,\r\n            (self.image_height, self.image_width, 3),\r\n            dtype=np.uint8\r\n        )\r\n        return image_data\r\n\r\n    def compress_image(self, image_data):\r\n        """Compress image to reduce bandwidth"""\r\n        # In real implementation, use image compression library\r\n        # like OpenCV: cv2.imencode(\'.jpg\', image_data, params)\r\n        return image_data.tobytes()  # Simplified\r\n\r\n    def publish_image(self):\r\n        """Publish optimized image"""\r\n        # Generate test image\r\n        image_data = self.generate_test_image()\r\n\r\n        # Create message\r\n        msg = Image()\r\n        msg.header = Header()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = f"camera_frame_{self.frame_id}"\r\n        msg.height = self.image_height\r\n        msg.width = self.image_width\r\n        msg.encoding = "rgb8"\r\n        msg.is_bigendian = False\r\n        msg.step = self.image_width * 3  # bytes per row\r\n\r\n        # Optimize based on settings\r\n        if self.publish_compressed:\r\n            # Compressed image (simplified)\r\n            compressed_data = self.compress_image(image_data)\r\n            msg.data = compressed_data\r\n        else:\r\n            # Raw image\r\n            msg.data = image_data.tobytes()\r\n\r\n        # Publish\r\n        self.image_pub.publish(msg)\r\n        self.frame_id += 1\r\n\r\n        # Log bandwidth usage\r\n        data_size = len(msg.data)\r\n        self.get_logger().debug(\r\n            f\'Published frame {self.frame_id}, size: {data_size} bytes\',\r\n            throttle_duration_sec=1.0\r\n        )\r\n\r\n# Advanced optimization with selective publishing\r\nclass SmartImagePublisher(OptimizedImagePublisher):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Previous image for difference calculation\r\n        self.previous_image = None\r\n        self.threshold = 0.1  # 10% change threshold\r\n        self.frame_skip = 2  # Publish every 2nd frame\r\n        self.frame_counter = 0\r\n\r\n    def calculate_difference(self, image1, image2):\r\n        """Calculate percentage difference between images"""\r\n        if image1 is None or image2 is None:\r\n            return 1.0\r\n\r\n        # Calculate absolute difference\r\n        diff = np.abs(image1.astype(float) - image2.astype(float))\r\n        return np.mean(diff) / 255.0\r\n\r\n    def publish_image(self):\r\n        """Publish image only if significant change"""\r\n        self.frame_counter += 1\r\n\r\n        # Skip frames based on frame_skip setting\r\n        if self.frame_counter % self.frame_skip != 0:\r\n            return\r\n\r\n        # Generate current image\r\n        current_image = self.generate_test_image()\r\n\r\n        # Calculate difference with previous image\r\n        diff = self.calculate_difference(self.previous_image, current_image)\r\n\r\n        # Only publish if significant change\r\n        if diff > self.threshold or self.previous_image is None:\r\n            super().publish_image()\r\n            self.previous_image = current_image.copy()\r\n            self.get_logger().debug(\r\n                f\'Published frame due to {diff:.1%} change\')\r\n        else:\r\n            self.get_logger().debug(\r\n                f\'Skipped frame, only {diff:.1%} change\')\n'})}),"\n",(0,t.jsx)(r.h3,{id:"522-message-type-design",children:"5.2.2 Message Type Design"}),"\n",(0,t.jsx)(r.p,{children:"Effective message type design is crucial for performance and maintainability:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagram: Message Type Hierarchy"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"Base Message\r\n\u251c\u2500\u2500 Header (timestamp, frame_id)\r\n\u251c\u2500\u2500 Core Data Fields\r\n\u251c\u2500\u2500 Metadata Fields\r\n\u2514\u2500\u2500 Optional Extensions\r\n\r\nGood Design:\r\nrobot_control_msg/Command\r\n\u251c\u2500\u2500 header (std_msgs/Header)\r\n\u251c\u2500\u2500 command_id (uint32)\r\n\u251c\u2500\u2500 command_type (uint8)\r\n\u251c\u2500\u2500 target_pose (geometry_msgs/PoseStamped)\r\n\u251c\u2500\u2500 velocity (geometry_msgs/Twist)\r\n\u251c\u2500\u2500 gripper_command (GripperCommand)\r\n\u2514\u2500\u2500 parameters (CustomParameters)\r\n\r\nAvoid: Large monolithic messages with many optional fields\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Custom Message Definition"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-msg#",metastring:"robot_control_msg/Command.msg",children:"std_msgs/Header header\r\nuint32 command_id\r\nuint8 type=0\r\nuint8 STOP=0\r\nuint8 MOVE=1\r\nuint8 GRASP=2\r\nuint8 RELEASE=3\r\n\r\n# Required fields based on command type\r\ngeometry_msgs/PoseStamped target_pose\r\ngeometry_msgs/Twist velocity\r\nGripperCommand gripper_command\r\n\r\n# Additional parameters\r\nCustomParameters[] parameters\r\n\r\n# robot_control_msg/GripperCommand.msg\r\nfloat64 position  # 0.0 (open) to 1.0 (closed)\r\nfloat64 force     # Maximum closing force\r\nbool relative     # True for relative positioning\r\n\r\n# robot_control_msg/CustomParameters.msg\r\nstring key\r\nstring value\n"})}),"\n",(0,t.jsx)(r.h3,{id:"523-topic-naming-conventions",children:"5.2.3 Topic Naming Conventions"}),"\n",(0,t.jsx)(r.admonition,{type:"tip",children:(0,t.jsx)(r.p,{children:"Follow ROS 2 topic naming conventions: use descriptive names, include hierarchy, and follow lower_case_with_underscores naming pattern."})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Topic Naming Examples"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-bash#",metastring:"Good naming conventions",children:"/camera/image_raw\r\n/camera/image_rect_color\r\n/camera/camera_info\r\n/robot_base/joint_states\r\n/robot_base/odom\r\n/arm_controller/command\r\n/arm_controller/state\r\n/gripper_controller/command\r\n/mobile_base/cmd_vel\r\n/mobile_base/odom\r\n/mobile_base/joint_states\r\n\r\n# Multi-robot systems\r\n/robot_1/camera/image_raw\r\n/robot_1/mobile_base/cmd_vel\r\n/robot_2/camera/image_raw\r\n/robot_2/mobile_base/cmd_vel\r\n\r\n# Sensor specific naming\r\n/front_lidar/scan\r\n/rear_lidar/scan\r\n/left_camera/image_raw\r\n/right_camera/image_raw\r\n/imu/data\r\n/gps/fix\n"})}),"\n",(0,t.jsx)(r.h2,{id:"53-service-design-patterns",children:"5.3 Service Design Patterns"}),"\n",(0,t.jsx)(r.h3,{id:"531-service-chain-patterns",children:"5.3.1 Service Chain Patterns"}),"\n",(0,t.jsx)(r.p,{children:"Services can be chained together for complex operations:"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Service Chain Implementation"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-pythonimport",metastring:"rclpy",children:'from rclpy.node import Node\r\nfrom example_interfaces.srv import AddTwoInts, SetBool\r\nfrom std_srvs.srv import Empty\r\n\r\nclass ServiceChainNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'service_chain_node\')\r\n\r\n        # Create service chain\r\n        self.setup_service_chain()\r\n\r\n        # Create master service\r\n        self.master_service = self.create_service(\r\n            Empty, \'master_operation\', self.master_operation_callback)\r\n\r\n        self.get_logger().info(\'Service chain node initialized\')\r\n\r\n    def setup_service_chain(self):\r\n        """Setup chain of services"""\r\n        # Service clients\r\n        self.add_client = self.create_client(AddTwoInts, \'add_two_ints\')\r\n        self.multiply_client = self.create_client(AddTwoInts, \'multiply\')\r\n        self.validate_client = self.create_client(SetBool, \'validate_result\')\r\n\r\n        # Wait for services\r\n        while not all([\r\n            self.add_client.wait_for_service(timeout_sec=1.0),\r\n            self.multiply_client.wait_for_service(timeout_sec=1.0),\r\n            self.validate_client.wait_for_service(timeout_sec=1.0)\r\n        ]):\r\n            self.get_logger().info(\'Waiting for services...\')\r\n\r\n    async def master_operation_callback(self, request, response):\r\n        """Master service that chains multiple services"""\r\n        try:\r\n            # Step 1: Add two numbers\r\n            add_request = AddTwoInts.Request()\r\n            add_request.a = 5\r\n            add_request.b = 3\r\n\r\n            add_future = self.add_client.call_async(add_request)\r\n            rclpy.spin_until_future_complete(self, add_future)\r\n            add_result = add_future.result()\r\n\r\n            if add_result.sum is None:\r\n                response.success = False\r\n                response.message = "Add service failed"\r\n                return response\r\n\r\n            # Step 2: Multiply result by 2\r\n            multiply_request = AddTwoInts.Request()\r\n            multiply_request.a = add_result.sum\r\n            multiply_request.b = 2\r\n\r\n            multiply_future = self.multiply_client.call_async(multiply_request)\r\n            rclpy.spin_until_future_complete(self, multiply_future)\r\n            multiply_result = multiply_future.result()\r\n\r\n            if multiply_result.sum is None:\r\n                response.success = False\r\n                response.message = "Multiply service failed"\r\n                return response\r\n\r\n            # Step 3: Validate result\r\n            validate_request = SetBool.Request()\r\n            validate_request.data = multiply_result.sum < 20\r\n\r\n            validate_future = self.validate_client.call_async(validate_request)\r\n            rclpy.spin_until_future_complete(self, validate_future)\r\n            validate_result = validate_future.result()\r\n\r\n            if validate_result.success:\r\n                response.success = True\r\n                response.message = f"Operation successful: final result = {multiply_result.sum}"\r\n            else:\r\n                response.success = False\r\n                response.message = "Validation failed"\r\n\r\n        except Exception as e:\r\n            response.success = False\r\n            response.message = f"Service chain error: {str(e)}"\r\n\r\n        return response\r\n\r\n# Enhanced master service response\r\nfrom example_interfaces.msg import String\r\n\r\nclass EnhancedServiceChainNode(ServiceChainNode):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Create enhanced master service\r\n        self.enhanced_service = self.create_service(\r\n            String, \'enhanced_operation\', self.enhanced_operation_callback)\r\n\r\n    async def enhanced_operation_callback(self, request, response):\r\n        """Enhanced service with detailed response"""\r\n        response.output = ""\r\n\r\n        try:\r\n            # Execute the same chain\r\n            base_response = await self.master_operation_callback(None, None)\r\n\r\n            if base_response.success:\r\n                response.output = "Service chain completed successfully:\\n"\r\n                response.output += f"- Initial addition: 5 + 3 = 8\\n"\r\n                response.output += f"- Multiplication: 8 * 2 = 16\\n"\r\n                response.output += f"- Validation: 16 < 20 = True\\n"\r\n                response.output += f"- Final result: {base_response.message}"\r\n            else:\r\n                response.output = f"Service chain failed: {base_response.message}"\r\n\r\n        except Exception as e:\r\n            response.output = f"Enhanced service error: {str(e)}"\r\n\r\n        return response\r\n\r\n# Synchronous service chain for better performance\r\nclass SyncServiceChainNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'sync_service_chain_node\')\r\n\r\n        # Create synchronized services\r\n        self.add_service = self.create_service(\r\n            AddTwoInts, \'fast_add\', self.add_callback)\r\n        self.multiply_service = self.create_service(\r\n            AddTwoInts, \'fast_multiply\', self.multiply_callback)\r\n\r\n        # Cache for performance\r\n        self.result_cache = {}\r\n\r\n        self.get_logger().info(\'Sync service chain node initialized\')\r\n\r\n    def add_callback(self, request, response):\r\n        """Fast addition with caching"""\r\n        cache_key = f"add_{request.a}_{request.b}"\r\n\r\n        if cache_key in self.result_cache:\r\n            response.sum = self.result_cache[cache_key]\r\n            self.get_logger().debug(f"Cache hit for {cache_key}")\r\n        else:\r\n            response.sum = request.a + request.b\r\n            self.result_cache[cache_key] = response.sum\r\n            self.get_logger().debug(f"Cache miss for {cache_key}")\r\n\r\n        return response\r\n\r\n    def multiply_callback(self, request, response):\r\n        """Fast multiplication"""\r\n        cache_key = f"mult_{request.a}_{request.b}"\r\n\r\n        if cache_key in self.result_cache:\r\n            response.sum = self.result_cache[cache_key]\r\n        else:\r\n            response.sum = request.a * request.b\r\n            self.result_cache[cache_key] = response.sum\r\n\r\n        return response\n'})}),"\n",(0,t.jsx)(r.h3,{id:"532-error-handling-in-services",children:"5.3.2 Error Handling in Services"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Robust Service Implementation"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp#include",metastring:"<rclcpp/rclcpp.hpp>",children:'#include <example_interfaces/srv/add_two_ints.hpp>\r\n#include <std_srvs/srv/trigger.hpp>\r\n\r\nclass RobustServiceNode : public rclcpp::Node {\r\npublic:\r\n    RobustServiceNode() : Node("robust_service_node") {\r\n\r\n        // Create robust calculator service\r\n        calculator_service_ = create_service<example_interfaces::srv::AddTwoInts>(\r\n            "robust_calculator",\r\n            std::bind(&RobustServiceNode::calculator_callback, this,\r\n                      std::placeholders::_1, std::placeholders::_2));\r\n\r\n        // Create health check service\r\n        health_service_ = create_service<std_srvs::srv::Trigger>(\r\n            "health_check",\r\n            std::bind(&RobustServiceNode::health_check_callback, this,\r\n                      std::placeholders::_1, std::placeholders::_2));\r\n\r\n        // Service statistics\r\n        request_count_ = 0;\r\n        error_count_ = 0;\r\n        last_request_time_ = now();\r\n\r\n        RCLCPP_INFO(get_logger(), "Robust service node initialized");\r\n    }\r\n\r\nprivate:\r\n    void calculator_callback(\r\n        const std::shared_ptr<example_interfaces::srv::AddTwoInts::Request> request,\r\n        std::shared_ptr<example_interfaces::srv::AddTwoInts::Response> response) {\r\n\r\n        request_count_++;\r\n        last_request_time_ = now();\r\n\r\n        try {\r\n            // Input validation\r\n            if (request->a < 0 || request->a > 1000 ||\r\n                request->b < 0 || request->b > 1000) {\r\n                response->success = false;\r\n                response->message = "Input values must be between 0 and 1000";\r\n                error_count_++;\r\n                return;\r\n            }\r\n\r\n            // Check for potential overflow\r\n            if (request->a > std::numeric_limits<int32_t>::max() - request->b) {\r\n                response->success = false;\r\n                response->message = "Integer overflow detected";\r\n                error_count_++;\r\n                return;\r\n            }\r\n\r\n            // Perform calculation\r\n            response->sum = request->a + request->b;\r\n            response->success = true;\r\n            response->message = "Calculation completed successfully";\r\n\r\n            RCLCPP_INFO(get_logger(),\r\n                       "Successfully calculated %d + %d = %d",\r\n                       request->a, request->b, response->sum);\r\n\r\n        } catch (const std::exception& e) {\r\n            RCLCPP_ERROR(get_logger(),\r\n                        "Exception in calculator service: %s", e.what());\r\n            response->success = false;\r\n            response->message = std::string("Internal error: ") + e.what();\r\n            error_count_++;\r\n        }\r\n    }\r\n\r\n    void health_check_callback(\r\n        const std::shared_ptr<std_srvs::srv::Trigger::Request> request,\r\n        std::shared_ptr<std_srvs::srv::Trigger::Response> response) {\r\n\r\n        try {\r\n            // Check service health\r\n            auto time_since_last_request = (now() - last_request_time_).seconds();\r\n\r\n            response->success = true;\r\n\r\n            std::ostringstream status;\r\n            status << "Service Status:\\n";\r\n            status << "  - Total requests: " << request_count_ << "\\n";\r\n            status << "  - Error count: " << error_count_ << "\\n";\r\n            status << "  - Error rate: "\r\n                   << (request_count_ > 0 ?\r\n                       (100.0 * error_count_ / request_count_) : 0.0) << "%\\n";\r\n            status << "  - Time since last request: "\r\n                   << time_since_last_request << " seconds\\n";\r\n            status << "  - Service uptime: "\r\n                   << (now().seconds() - start_time_.seconds()) << " seconds";\r\n\r\n            response->message = status.str();\r\n\r\n        } catch (const std::exception& e) {\r\n            RCLCPP_ERROR(get_logger(),\r\n                        "Exception in health check: %s", e.what());\r\n            response->success = false;\r\n            response->message = "Health check failed";\r\n        }\r\n    }\r\n\r\n    // Service clients\r\n    rclcpp::Service<example_interfaces::srv::AddTwoInts>::SharedPtr calculator_service_;\r\n    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr health_service_;\r\n\r\n    // Statistics\r\n    uint64_t request_count_;\r\n    uint64_t error_count_;\r\n    rclcpp::Time last_request_time_;\r\n    rclcpp::Time start_time_;\r\n};\r\n\r\n// Service with timeout and retry mechanisms\r\nclass AdvancedServiceNode : public rclcpp::Node {\r\npublic:\r\n    AdvancedServiceNode() : Node("advanced_service_node") {\r\n\r\n        // Create service with timeout capability\r\n        timeout_service_ = create_service<std_srvs::srv::Trigger>(\r\n            "timeout_service",\r\n            std::bind(&AdvancedServiceNode::timeout_callback, this,\r\n                      std::placeholders::_1, std::placeholders::_2));\r\n\r\n        // Create service with retry mechanism\r\n        retry_service_ = create_service<std_srvs::srv::Trigger>(\r\n            "retry_service",\r\n            std::bind(&AdvancedServiceNode::retry_callback, this,\r\n                      std::placeholders::_1, std::placeholders::_2));\r\n\r\n        RCLCPP_INFO(get_logger(), "Advanced service node initialized");\r\n    }\r\n\r\nprivate:\r\n    void timeout_callback(\r\n        const std::shared_ptr<std_srvs::srv::Trigger::Request> request,\r\n        std::shared_ptr<std_srvs::srv::Trigger::Response> response) {\r\n\r\n        // Service that demonstrates timeout handling\r\n        auto start_time = now();\r\n\r\n        try {\r\n            // Simulate long operation (5 seconds)\r\n            rclcpp::sleep_for(std::chrono::seconds(5));\r\n\r\n            auto elapsed = (now() - start_time).seconds();\r\n\r\n            response->success = true;\r\n            response->message = "Timeout service completed in " +\r\n                               std::to_string(elapsed) + " seconds";\r\n\r\n        } catch (const std::exception& e) {\r\n            response->success = false;\r\n            response->message = "Timeout service failed: " + std::string(e.what());\r\n        }\r\n    }\r\n\r\n    void retry_callback(\r\n        const std::shared_ptr<std_srvs::srv::Trigger::Request> request,\r\n        std::shared_ptr<std_srvs::srv::Trigger::Response> response) {\r\n\r\n        // Service that demonstrates retry mechanism\r\n        int max_attempts = 3;\r\n        int attempt = 0;\r\n        bool success = false;\r\n\r\n        while (attempt < max_attempts && !success) {\r\n            attempt++;\r\n\r\n            try {\r\n                // Simulate operation that might fail\r\n                double random_value = (double)rand() / RAND_MAX;\r\n\r\n                if (random_value < 0.7) {  // 70% success rate\r\n                    success = true;\r\n                    response->success = true;\r\n                    response->message = "Retry service succeeded after " +\r\n                                       std::to_string(attempt) + " attempts";\r\n                    break;\r\n                } else {\r\n                    // Simulate failure\r\n                    if (attempt < max_attempts) {\r\n                        RCLCPP_INFO(get_logger(),\r\n                                   "Attempt %d failed, retrying...", attempt);\r\n                        rclcpp::sleep_for(std::chrono::milliseconds(100));\r\n                    }\r\n                }\r\n\r\n            } catch (const std::exception& e) {\r\n                RCLCPP_ERROR(get_logger(),\r\n                            "Exception in attempt %d: %s", attempt, e.what());\r\n            }\r\n        }\r\n\r\n        if (!success) {\r\n            response->success = false;\r\n            response->message = "Retry service failed after " +\r\n                               std::to_string(max_attempts) + " attempts";\r\n        }\r\n    }\r\n\r\n    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr timeout_service_;\r\n    rclcpp::Service<std_srvs::srv::Trigger>::SharedPtr retry_service_;\r\n};\n'})}),"\n",(0,t.jsx)(r.h2,{id:"54-advanced-action-implementation",children:"5.4 Advanced Action Implementation"}),"\n",(0,t.jsx)(r.h3,{id:"541-complex-action-workflows",children:"5.4.1 Complex Action Workflows"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Multi-Stage Action Server"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-pythonimport",metastring:"rclpy",children:'from rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom rclpy.duration import Duration\r\n\r\nfrom example_interfaces.action import Fibonacci\r\nfrom std_msgs.msg import String\r\n\r\nclass MultiStageActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__(\'multi_stage_action_server\')\r\n\r\n        # Create action server\r\n        self.action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            \'fibonacci\',\r\n            self.execute_callback,\r\n            cancel_callback=self.cancel_callback)\r\n\r\n        # Event publisher for stage tracking\r\n        self.stage_pub = self.create_publisher(String, \'/action_stage\', 10)\r\n\r\n        # Stage definitions\r\n        self.stages = [\r\n            "initialization",\r\n            "calculation",\r\n            "validation",\r\n            "finalization"\r\n        ]\r\n\r\n        self.current_stage = 0\r\n        self.action_active = False\r\n\r\n        self.get_logger().info(\'Multi-stage action server initialized\')\r\n\r\n    async def execute_callback(self, goal_handle):\r\n        """Execute multi-stage action"""\r\n        self.action_active = True\r\n        self.current_stage = 0\r\n\r\n        # Get goal\r\n        order = goal_handle.request.order\r\n\r\n        self.get_logger().info(f\'Executing Fibonacci sequence of order {order}\')\r\n\r\n        # Publish initial stage\r\n        self.publish_stage("initialization")\r\n\r\n        # Stage 1: Initialization\r\n        if not await self.stage_initialization(order, goal_handle):\r\n            goal_handle.abort()\r\n            return Fibonacci.Result()\r\n\r\n        # Stage 2: Calculation\r\n        sequence = await self.stage_calculation(order, goal_handle)\r\n        if sequence is None:\r\n            goal_handle.abort()\r\n            return Fibonacci.Result()\r\n\r\n        # Stage 3: Validation\r\n        if not await self.stage_validation(sequence, goal_handle):\r\n            goal_handle.abort()\r\n            return Fibonacci.Result()\r\n\r\n        # Stage 4: Finalization\r\n        if not await self.stage_finalization(sequence, goal_handle):\r\n            goal_handle.abort()\r\n            return Fibonacci.Result()\r\n\r\n        # Complete action\r\n        goal_handle.succeed()\r\n\r\n        result = Fibonacci.Result()\r\n        result.sequence = sequence\r\n\r\n        self.get_logger().info(f\'Action completed: sequence = {sequence}\')\r\n\r\n        self.action_active = False\r\n        return result\r\n\r\n    async def stage_initialization(self, order, goal_handle):\r\n        """Stage 1: Initialize resources"""\r\n        self.publish_stage("initialization")\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.stage = "initialization"\r\n        feedback_msg.progress = 0.0\r\n\r\n        try:\r\n            # Validate input\r\n            if order < 0 or order > 100:\r\n                self.get_logger().error(f\'Invalid order: {order}\')\r\n                return False\r\n\r\n            # Initialize resources\r\n            # Simulate initialization time\r\n            for i in range(10):\r\n                if goal_handle.is_cancel_requested:\r\n                    return False\r\n\r\n                progress = (i + 1) / 10.0 * 25.0  # 0-25% for initialization\r\n                feedback_msg.progress = progress\r\n                goal_handle.publish_feedback(feedback_msg)\r\n\r\n                self.get_logger().debug(f\'Initialization progress: {progress:.1f}%\')\r\n                rclpy.spin_once(self, timeout_sec=0.1)\r\n                await asyncio.sleep(0.1)\r\n\r\n            self.get_logger().info(\'Initialization completed\')\r\n            return True\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Initialization failed: {e}\')\r\n            return False\r\n\r\n    async def stage_calculation(self, order, goal_handle):\r\n        """Stage 2: Calculate Fibonacci sequence"""\r\n        self.publish_stage("calculation")\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.stage = "calculation"\r\n\r\n        try:\r\n            sequence = []\r\n            a, b = 0, 1\r\n\r\n            for i in range(order + 1):\r\n                # Check for cancellation\r\n                if goal_handle.is_cancel_requested:\r\n                    return None\r\n\r\n                # Calculate next number\r\n                if i == 0:\r\n                    sequence.append(a)\r\n                else:\r\n                    sequence.append(b)\r\n                    a, b = b, a + b\r\n\r\n                # Update feedback\r\n                progress = 25.0 + (i + 1) / (order + 1) * 50.0  # 25-75% for calculation\r\n                feedback_msg.partial_sequence = sequence\r\n                feedback_msg.progress = progress\r\n                goal_handle.publish_feedback(feedback_msg)\r\n\r\n                self.get_logger().debug(f\'Calculation progress: {progress:.1f}%, current value: {b}\')\r\n                rclpy.spin_once(self, timeout_sec=0.1)\r\n\r\n                # Add delay to make stage visible\r\n                if i % 10 == 0:\r\n                    await asyncio.sleep(0.1)\r\n\r\n            self.get_logger().info(\'Calculation completed\')\r\n            return sequence\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Calculation failed: {e}\')\r\n            return None\r\n\r\n    async def stage_validation(self, sequence, goal_handle):\r\n        """Stage 3: Validate results"""\r\n        self.publish_stage("validation")\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.stage = "validation"\r\n\r\n        try:\r\n            # Validate Fibonacci sequence\r\n            for i in range(2, len(sequence)):\r\n                expected = sequence[i-1] + sequence[i-2]\r\n                if sequence[i] != expected:\r\n                    self.get_logger().error(f\'Validation failed at index {i}: \'\r\n                                           f\'{sequence[i]} != {expected}\')\r\n                    return False\r\n\r\n            # Update progress\r\n            for i in range(10):\r\n                if goal_handle.is_cancel_requested:\r\n                    return False\r\n\r\n                progress = 75.0 + (i + 1) / 10.0 * 20.0  # 75-95% for validation\r\n                feedback_msg.progress = progress\r\n                feedback_msg.partial_sequence = sequence\r\n                goal_handle.publish_feedback(feedback_msg)\r\n\r\n                rclpy.spin_once(self, timeout_sec=0.1)\r\n                await asyncio.sleep(0.05)\r\n\r\n            self.get_logger().info(\'Validation completed\')\r\n            return True\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Validation failed: {e}\')\r\n            return False\r\n\r\n    async def stage_finalization(self, sequence, goal_handle):\r\n        """Stage 4: Finalize and cleanup"""\r\n        self.publish_stage("finalization")\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.stage = "finalization"\r\n\r\n        try:\r\n            # Finalize results\r\n            result_info = {\r\n                \'sequence_length\': len(sequence),\r\n                \'final_value\': sequence[-1] if sequence else 0,\r\n                \'sum\': sum(sequence) if sequence else 0\r\n            }\r\n\r\n            # Update progress to 100%\r\n            for i in range(5):\r\n                if goal_handle.is_cancel_requested:\r\n                    return False\r\n\r\n                progress = 95.0 + (i + 1) / 5.0 * 5.0  # 95-100% for finalization\r\n                feedback_msg.progress = progress\r\n                feedback_msg.partial_sequence = sequence\r\n                goal_handle.publish_feedback(feedback_msg)\r\n\r\n                rclpy.spin_once(self, timeout_sec=0.1)\r\n                await asyncio.sleep(0.05)\r\n\r\n            self.get_logger().info(f\'Finalization completed: {result_info}\')\r\n            return True\r\n\r\n        except Exception as e:\r\n            self.get_logger().error(f\'Finalization failed: {e}\')\r\n            return False\r\n\r\n    def cancel_callback(self, goal_handle):\r\n        """Handle action cancellation"""\r\n        self.get_logger().info(\'Received cancel request\')\r\n        self.action_active = False\r\n        return True\r\n\r\n    def publish_stage(self, stage):\r\n        """Publish current stage information"""\r\n        msg = String()\r\n        msg.data = f\'Current stage: {stage}\'\r\n        self.stage_pub.publish(msg)\r\n        self.current_stage = self.stages.index(stage) if stage in self.stages else 0\r\n\r\n# Extended feedback message definition (would be in .msg file)\r\n# example_interfaces/action/FibonacciExtended.action\r\n# int32 order\r\n# ---\r\n# int32[] sequence\r\n# string stage\r\n# float64 progress\r\n# ---\r\n# int32[] sequence\r\n# string status\r\n# float64 execution_time\n'})}),"\n",(0,t.jsx)(r.h3,{id:"542-action-client-with-retry-and-timeout",children:"5.4.2 Action Client with Retry and Timeout"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Advanced Action Client"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-cpp#include",metastring:"<rclcpp/rclcpp.hpp>",children:'#include <rclcpp_action/rclcpp_action.hpp>\r\n#include <example_interfaces/action/fibonacci.hpp>\r\n#include <chrono>\r\n#include <memory>\r\n\r\nclass AdvancedActionClient : public rclcpp::Node {\r\npublic:\r\n    AdvancedActionClient() : Node("advanced_action_client") {\r\n\r\n        // Create action client\r\n        action_client_ = rclcpp_action::create_client<Fibonacci>(\r\n            this, "fibonacci");\r\n\r\n        // Wait for action server\r\n        while (!action_client_->wait_for_action_server(std::chrono::seconds(1))) {\r\n            if (!rclcpp::ok()) {\r\n                RCLCPP_ERROR(get_logger(), "Interrupted while waiting for action server");\r\n                return;\r\n            }\r\n            RCLCPP_INFO(get_logger(), "Waiting for action server...");\r\n        }\r\n\r\n        RCLCPP_INFO(get_logger(), "Advanced action client initialized");\r\n    }\r\n\r\n    void send_goal_with_retry(int order, int max_retries = 3) {\r\n        int retry_count = 0;\r\n\r\n        while (retry_count < max_retries) {\r\n            if (send_goal(order)) {\r\n                RCLCPP_INFO(get_logger(), "Goal completed successfully");\r\n                return;\r\n            } else {\r\n                retry_count++;\r\n                RCLCPP_WARN(get_logger(),\r\n                           "Goal failed, retrying (%d/%d)...",\r\n                           retry_count, max_retries);\r\n\r\n                if (retry_count < max_retries) {\r\n                    std::this_thread::sleep_for(std::chrono::seconds(1));\r\n                }\r\n            }\r\n        }\r\n\r\n        RCLCPP_ERROR(get_logger(), "Goal failed after %d retries", max_retries);\r\n    }\r\n\r\n    void send_goal_with_timeout(int order, double timeout_seconds = 10.0) {\r\n        auto goal_msg = Fibonacci::Goal();\r\n        goal_msg.order = order;\r\n\r\n        RCLCPP_INFO(get_logger(), "Sending goal with timeout %.1f seconds", timeout_seconds);\r\n\r\n        auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions();\r\n        send_goal_options.goal_response_callback =\r\n            std::bind(&AdvancedActionClient::goal_response_callback, this, std::placeholders::_1);\r\n        send_goal_options.feedback_callback =\r\n            std::bind(&AdvancedActionClient::feedback_callback, this, std::placeholders::_1, std::placeholders::_2);\r\n        send_goal_options.result_callback =\r\n            std::bind(&AdvancedActionClient::result_callback, this, std::placeholders::_1);\r\n\r\n        // Send goal\r\n        auto goal_handle_future = action_client_->async_send_goal(goal_msg, send_goal_options);\r\n\r\n        // Wait for goal completion with timeout\r\n        if (rclcpp::spin_until_future_complete(\r\n                this->get_node_base_interface(),\r\n                goal_handle_future,\r\n                std::chrono::duration<double>(timeout_seconds)) ==\r\n            rclcpp::FutureReturnCode::SUCCESS) {\r\n\r\n            auto goal_handle = goal_handle_future.get();\r\n            if (goal_handle) {\r\n                RCLCPP_INFO(get_logger(), "Goal completed within timeout");\r\n            } else {\r\n                RCLCPP_ERROR(get_logger(), "Goal was rejected");\r\n            }\r\n        } else {\r\n            RCLCPP_ERROR(get_logger(), "Goal timed out after %.1f seconds", timeout_seconds);\r\n            // Cancel the goal\r\n            action_client_->async_cancel_all_goals();\r\n        }\r\n    }\r\n\r\n    void send_concurrent_goals() {\r\n        RCLCPP_INFO(get_logger(), "Sending multiple concurrent goals");\r\n\r\n        // Send multiple goals concurrently\r\n        std::vector<std::shared_future<rclcpp_action::ClientGoalHandle<Fibonacci>::SharedPtr>> futures;\r\n\r\n        for (int i = 0; i < 3; ++i) {\r\n            auto goal_msg = Fibonacci::Goal();\r\n            goal_msg.order = 10 + i * 2;  // 10, 12, 14\r\n\r\n            auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions();\r\n            send_goal_options.result_callback =\r\n                [this, i](const rclcpp_action::ClientGoalHandle<Fibonacci>::WrappedResult & result) {\r\n                    switch (result.code) {\r\n                        case rclcpp_action::ResultCode::SUCCEEDED:\r\n                            RCLCPP_INFO(get_logger(), "Goal %d succeeded", i);\r\n                            break;\r\n                        case rclcpp_action::ResultCode::ABORTED:\r\n                            RCLCPP_WARN(get_logger(), "Goal %d was aborted", i);\r\n                            break;\r\n                        case rclcpp_action::ResultCode::CANCELED:\r\n                            RCLCPP_INFO(get_logger(), "Goal %d was canceled", i);\r\n                            break;\r\n                        default:\r\n                            RCLCPP_ERROR(get_logger(), "Goal %d failed with unknown result code", i);\r\n                            break;\r\n                    }\r\n                };\r\n\r\n            auto future = action_client_->async_send_goal(goal_msg, send_goal_options);\r\n            futures.push_back(future);\r\n        }\r\n\r\n        // Wait for all goals to complete\r\n        for (auto& future : futures) {\r\n            rclcpp::spin_until_future_complete(this->get_node_base_interface(), future);\r\n        }\r\n\r\n        RCLCPP_INFO(get_logger(), "All concurrent goals completed");\r\n    }\r\n\r\nprivate:\r\n    bool send_goal(int order) {\r\n        auto goal_msg = Fibonacci::Goal();\r\n        goal_msg.order = order;\r\n\r\n        RCLCPP_INFO(get_logger(), "Sending goal: order = %d", order);\r\n\r\n        auto send_goal_options = rclcpp_action::Client<Fibonacci>::SendGoalOptions();\r\n        send_goal_options.goal_response_callback =\r\n            std::bind(&AdvancedActionClient::goal_response_callback, this, std::placeholders::_1);\r\n        send_goal_options.feedback_callback =\r\n            std::bind(&AdvancedActionClient::feedback_callback, this, std::placeholders::_1, std::placeholders::_2);\r\n        send_goal_options.result_callback =\r\n            std::bind(&AdvancedActionClient::result_callback, this, std::placeholders::_1);\r\n\r\n        // Send goal and wait for result\r\n        auto goal_handle_future = action_client_->async_send_goal(goal_msg, send_goal_options);\r\n\r\n        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), goal_handle_future) !=\r\n            rclcpp::FutureReturnCode::SUCCESS) {\r\n            RCLCPP_ERROR(get_logger(), "Failed to send goal");\r\n            return false;\r\n        }\r\n\r\n        auto goal_handle = goal_handle_future.get();\r\n        if (!goal_handle) {\r\n            RCLCPP_ERROR(get_logger(), "Goal was rejected");\r\n            return false;\r\n        }\r\n\r\n        // Wait for result\r\n        auto result_future = goal_handle->async_get_result();\r\n\r\n        if (rclcpp::spin_until_future_complete(this->get_node_base_interface(), result_future) !=\r\n            rclcpp::FutureReturnCode::SUCCESS) {\r\n            RCLCPP_ERROR(get_logger(), "Failed to get result");\r\n            return false;\r\n        }\r\n\r\n        auto result = result_future.get();\r\n        return result.code == rclcpp_action::ResultCode::SUCCEEDED;\r\n    }\r\n\r\n    void goal_response_callback(const rclcpp_action::ClientGoalHandle<Fibonacci>::SharedPtr & goal_handle) {\r\n        if (!goal_handle) {\r\n            RCLCPP_ERROR(get_logger(), "Goal was rejected");\r\n        } else {\r\n            RCLCPP_INFO(get_logger(), "Goal accepted by server");\r\n        }\r\n    }\r\n\r\n    void feedback_callback(\r\n        rclcpp_action::ClientGoalHandle<Fibonacci>::SharedPtr,\r\n        const std::shared_ptr<const Fibonacci::Feedback> feedback) {\r\n\r\n        RCLCPP_INFO(get_logger(),\r\n                   "Received feedback: partial_sequence length = %zu",\r\n                   feedback->partial_sequence.size());\r\n    }\r\n\r\n    void result_callback(const rclcpp_action::ClientGoalHandle<Fibonacci>::WrappedResult & result) {\r\n        switch (result.code) {\r\n            case rclcpp_action::ResultCode::SUCCEEDED:\r\n                RCLCPP_INFO(get_logger(), "Goal succeeded");\r\n                RCLCPP_INFO(get_logger(), "Final sequence:");\r\n                for (auto number : result.result->sequence) {\r\n                    RCLCPP_INFO(get_logger(), "  %d", number);\r\n                }\r\n                break;\r\n            case rclcpp_action::ResultCode::ABORTED:\r\n                RCLCPP_ERROR(get_logger(), "Goal was aborted");\r\n                break;\r\n            case rclcpp_action::ResultCode::CANCELED:\r\n                RCLCPP_ERROR(get_logger(), "Goal was canceled");\r\n                break;\r\n            default:\r\n                RCLCPP_ERROR(get_logger(), "Unknown result code");\r\n                break;\r\n        }\r\n    }\r\n\r\n    rclcpp_action::Client<Fibonacci>::SharedPtr action_client_;\r\n};\n'})}),"\n",(0,t.jsx)(r.h2,{id:"55-real-world-communication-patterns",children:"5.5 Real-world Communication Patterns"}),"\n",(0,t.jsx)(r.h3,{id:"551-sensor-processing-pipeline",children:"5.5.1 Sensor Processing Pipeline"}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Diagram: Sensor Processing Architecture"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{children:"Raw Sensor Data\r\n       \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Sensor Driver \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n       \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Preprocessing  \u2502\r\n\u2502 - Noise Filter  \u2502\r\n\u2502 - Calibration   \u2502\r\n\u2502 - Validation    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n       \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Feature        \u2502\r\n\u2502  Extraction     \u2502\r\n\u2502 - Detection     \u2502\r\n\u2502 - Recognition   \u2502\r\n\u2502 - Tracking      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n       \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Sensor Fusion  \u2502\r\n\u2502 - Kalman Filter \u2502\r\n\u2502 - Weighting     \u2502\r\n\u2502 - Validation    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n       \u2193\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502  Publishing     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,t.jsx)(r.p,{children:(0,t.jsx)(r.strong,{children:"Example: Sensor Processing Pipeline"})}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-pythonimport",metastring:"rclpy",children:"from rclpy.node import Node\r\nfrom sensor_msgs.msg import Image, LaserScan\r\nfrom geometry_msgs.msg import PointStamped\r\nfrom nav_msgs.msg import Odometry\r\nimport numpy as np\r\n\r\nclass SensorProcessingPipeline(Node):\r\n    def __init__(self):\r\n        super().__init__('sensor_processing_pipeline')\r\n\r\n        # Raw sensor subscribers\r\n        self.image_sub = self.create_subscription(\r\n            Image, '/camera/image_raw', self.image_callback, 10)\r\n        self.lidar_sub = self.create_subscription(\r\n            LaserScan, '/lidar/scan', self.lidar_callback, 10)\r\n        self.odom_sub = self.create_subscription(\r\n            Odometry, '/odom', self.odom_callback, 10)\r\n\r\n        # Processed data publishers\r\n        self.obstacle_pub = self.create_publisher(\r\n            PointStamped, '/obstacles', 10)\r\n        self.trajectory_pub = self.create_publisher(\r\n            PointStamped, '/trajectory', 10)\r\n\r\n        # Processing state\r\n        self.latest_image = None\r\n        self.latest_scan = None\r\n        latest_odom = None\r\n\r\n        # Processing parameters\r\n        self.obstacle_threshold = 2.0  # meters\r\n        self.publish_rate = 10.0  # Hz\r\n\r\n        # Processing timer\r\n        self.processing_timer = self.create_timer(\r\n            1.0 / self.publish_rate, self.process_sensor_data)\r\n\r\n        self.get_logger().info('Sensor processing pipeline initialized')\r\n\r\n    def image_callback(self, msg):\r\n        \"\"\"Handle raw image data\"\"\"\r\n        # Preprocess image\r\n        processed_image = self.preprocess_image(msg)\r\n\r\n        # Extract features\r\n        features = self.extract_image_features(processed_image)\r\n\r\n        # Store for fusion\r\n        self.latest_image = {\r\n            'header': msg.header,\r\n            'features': features,\r\n            'timestamp': self.get_clock().now()\r\n        }\r\n\r\n    def lidar_callback(self, msg):\r\n        \"\"\"Handle raw LiDAR data\"\"\"\r\n        # Preprocess scan\r\n        processed_scan = self.preprocess_lidar(msg)\r\n\r\n        # Extract obstacles\r\n        obstacles = self.extract_obstacles(processed_scan)\r\n\r\n        # Store for fusion\r\n        self.latest_scan = {\r\n            'header': msg.header,\r\n            'obstacles': obstacles,\r\n            'timestamp': self.get_clock().now()\r\n        }\r\n\r\n    def odom_callback(self, msg):\r\n        \"\"\"Handle odometry data\"\"\"\r\n        self.latest_odom = {\r\n            'header': msg.header,\r\n            'pose': msg.pose.pose,\r\n            'twist': msg.twist.twist,\r\n            'timestamp': self.get_clock().now()\r\n        }\r\n\r\n    def preprocess_image(self, msg):\r\n        \"\"\"Preprocess raw image\"\"\"\r\n        # In real implementation, use OpenCV or similar\r\n        # Convert to grayscale, apply filters, etc.\r\n        return msg\r\n\r\n    def extract_image_features(self, image_msg):\r\n        \"\"\"Extract features from preprocessed image\"\"\"\r\n        # Simulate feature extraction\r\n        features = []\r\n\r\n        # Create test features\r\n        for i in range(5):\r\n            feature = {\r\n                'id': i,\r\n                'position': (np.random.rand() * image_msg.width,\r\n                            np.random.rand() * image_msg.height),\r\n                'confidence': np.random.rand(),\r\n                'type': 'corner'\r\n            }\r\n            features.append(feature)\r\n\r\n        return features\r\n\r\n    def preprocess_lidar(self, msg):\r\n        \"\"\"Preprocess raw LiDAR scan\"\"\"\r\n        # Remove invalid readings\r\n        valid_ranges = []\r\n        for i, r in enumerate(msg.ranges):\r\n            if msg.range_min <= r <= msg.range_max:\r\n                valid_ranges.append(r)\r\n            else:\r\n                valid_ranges.append(float('inf'))\r\n\r\n        # Smooth the data\r\n        smoothed_ranges = self.smooth_ranges(valid_ranges)\r\n\r\n        return {\r\n            'ranges': smoothed_ranges,\r\n            'angle_min': msg.angle_min,\r\n            'angle_max': msg.angle_max,\r\n            'angle_increment': msg.angle_increment\r\n        }\r\n\r\n    def smooth_ranges(self, ranges):\r\n        \"\"\"Smooth LiDAR range data\"\"\"\r\n        if len(ranges) < 3:\r\n            return ranges\r\n\r\n        smoothed = []\r\n        for i in range(len(ranges)):\r\n            if i == 0 or i == len(ranges) - 1:\r\n                smoothed.append(ranges[i])\r\n            else:\r\n                # Simple moving average\r\n                avg = (ranges[i-1] + ranges[i] + ranges[i+1]) / 3.0\r\n                smoothed.append(avg)\r\n\r\n        return smoothed\r\n\r\n    def extract_obstacles(self, scan_data):\r\n        \"\"\"Extract obstacle positions from LiDAR scan\"\"\"\r\n        obstacles = []\r\n\r\n        for i, r in enumerate(scan_data['ranges']):\r\n            if r < self.obstacle_threshold:\r\n                # Convert polar to Cartesian\r\n                angle = scan_data['angle_min'] + i * scan_data['angle_increment']\r\n                x = r * np.cos(angle)\r\n                y = r * np.sin(angle)\r\n\r\n                obstacles.append({\r\n                    'position': (x, y),\r\n                    'distance': r,\r\n                    'angle': angle,\r\n                    'confidence': 1.0 / (1.0 + r)  # Closer obstacles more confident\r\n                })\r\n\r\n        return obstacles\r\n\r\n    def process_sensor_data(self):\r\n        \"\"\"Main processing function\"\"\"\r\n        if not self.latest_scan or not self.latest_odom:\r\n            return\r\n\r\n        # Publish detected obstacles\r\n        self.publish_obstacles()\r\n\r\n        # Publish trajectory (example)\r\n        self.publish_trajectory()\r\n\r\n    def publish_obstacles(self):\r\n        \"\"\"Publish detected obstacles\"\"\"\r\n        for obstacle in self.latest_scan['obstacles']:\r\n            msg = PointStamped()\r\n            msg.header = self.latest_scan['header']\r\n            msg.header.frame_id = 'base_link'\r\n            msg.point.x = obstacle['position'][0]\r\n            msg.point.y = obstacle['position'][1]\r\n            msg.point.z = 0.0\r\n\r\n            self.obstacle_pub.publish(msg)\r\n\r\n    def publish_trajectory(self):\r\n        \"\"\"Publish trajectory point\"\"\"\r\n        if self.latest_odom:\r\n            msg = PointStamped()\r\n            msg.header = self.latest_odom['header']\r\n            msg.header.frame_id = 'base_link'\r\n            msg.point.x = self.latest_odom['pose'].position.x\r\n            msg.point.y = self.latest_odom['pose'].position.y\r\n            msg.point.z = self.latest_odom['pose'].position.z\r\n\r\n            self.trajectory_pub.publish(msg)\r\n\r\n# Advanced sensor fusion with Kalman filtering\r\nclass AdvancedSensorFusion(SensorProcessingPipeline):\r\n    def __init__(self):\r\n        super().__init__()\r\n\r\n        # Kalman filter for sensor fusion\r\n        self.kf_state = np.zeros([6, 1])  # [x, y, z, vx, vy, vz]\r\n        self.kf_covariance = np.eye(6) * 0.1\r\n        self.last_fusion_time = self.get_clock().now()\r\n\r\n        # Fused data publisher\r\n        self.fused_odom_pub = self.create_publisher(\r\n            Odometry, '/fused_odom', 10)\r\n\r\n    def process_sensor_data(self):\r\n        \"\"\"Advanced processing with sensor fusion\"\"\"\r\n        super().process_sensor_data()\r\n\r\n        # Perform sensor fusion\r\n        self.sensor_fusion()\r\n\r\n    def sensor_fusion(self):\r\n        \"\"\"Perform Kalman filter-based sensor fusion\"\"\"\r\n        current_time = self.get_clock().now()\r\n        dt = (current_time - self.last_fusion_time).nanoseconds / 1e9\r\n\r\n        if dt > 0:\r\n            # Prediction step\r\n            self.predict_step(dt)\r\n\r\n            # Update step with measurements\r\n            if self.latest_odom:\r\n                self.update_step_with_odom()\r\n\r\n            # Publish fused odometry\r\n            self.publish_fused_odometry()\r\n\r\n            self.last_fusion_time = current_time\r\n\r\n    def predict_step(self, dt):\r\n        \"\"\"Kalman filter prediction step\"\"\"\r\n        # State transition matrix\r\n        F = np.array([\r\n            [1, 0, 0, dt, 0, 0],  # x\r\n            [0, 1, 0, 0, dt, 0],  # y\r\n            [0, 0, 1, 0, 0, dt],  # z\r\n            [0, 0, 0, 1, 0, 0],  # vx\r\n            [0, 0, 0, 0, 1, 0],  # vy\r\n            [0, 0, 0, 0, 0, 1]   # vz\r\n        ])\r\n\r\n        # Process noise\r\n        Q = np.eye(6) * 0.01\r\n\r\n        # Predict\r\n        self.kf_state = F @ self.kf_state\r\n        self.kf_covariance = F @ self.kf_covariance @ F.T + Q\r\n\r\n    def update_step_with_odom(self):\r\n        \"\"\"Update step with odometry measurement\"\"\"\r\n        # Measurement matrix (we only measure position)\r\n        H = np.array([\r\n            [1, 0, 0, 0, 0, 0],\r\n            [0, 1, 0, 0, 0, 0],\r\n            [0, 0, 1, 0, 0, 0]\r\n        ])\r\n\r\n        # Measurement noise\r\n        R = np.eye(3) * 0.1\r\n\r\n        # Measurement\r\n        z = np.array([\r\n            [self.latest_odom['pose'].position.x],\r\n            [self.latest_odom['pose'].position.y],\r\n            [self.latest_odom['pose'].position.z]\r\n        ])\r\n\r\n        # Kalman gain\r\n        S = H @ self.kf_covariance @ H.T + R\r\n        K = self.kf_covariance @ H.T @ np.linalg.inv(S)\r\n\r\n        # Update\r\n        y = z - H @ self.kf_state\r\n        self.kf_state = self.kf_state + K @ y\r\n        self.kf_covariance = (np.eye(6) - K @ H) @ self.kf_covariance\r\n\r\n    def publish_fused_odometry(self):\r\n        \"\"\"Publish fused odometry\"\"\"\r\n        msg = Odometry()\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = 'odom'\r\n        msg.child_frame_id = 'base_link'\r\n\r\n        # Set position\r\n        msg.pose.pose.position.x = self.kf_state[0, 0]\r\n        msg.pose.pose.position.y = self.kf_state[1, 0]\r\n        msg.pose.pose.position.z = self.kf_state[2, 0]\r\n\r\n        # Set velocity\r\n        msg.twist.twist.linear.x = self.kf_state[3, 0]\r\n        msg.twist.twist.linear.y = self.kf_state[4, 0]\r\n        msg.twist.twist.linear.z = self.kf_state[5, 0]\r\n\r\n        self.fused_odom_pub.publish(msg)\n"})}),"\n",(0,t.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(r.p,{children:"This chapter explored advanced ROS 2 communication patterns and architectural approaches essential for building complex, robust robotic systems. We covered sophisticated node designs, optimized topic patterns, robust service implementations, and complex action workflows."}),"\n",(0,t.jsx)(r.p,{children:"Key takeaways:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Node composition and multi-threading improve performance and reduce overhead"}),"\n",(0,t.jsx)(r.li,{children:"Lifecycle management provides controlled startup and shutdown procedures"}),"\n",(0,t.jsx)(r.li,{children:"Bandwidth optimization and proper message design are crucial for high-frequency data"}),"\n",(0,t.jsx)(r.li,{children:"Robust error handling and retry mechanisms ensure system reliability"}),"\n",(0,t.jsx)(r.li,{children:"Multi-stage actions with detailed feedback enable complex workflows"}),"\n",(0,t.jsx)(r.li,{children:"Sensor processing pipelines demonstrate real-world integration patterns"}),"\n",(0,t.jsx)(r.li,{children:"Advanced patterns like sensor fusion with Kalman filtering enhance system capabilities"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsx)(r.h3,{id:"exercise-51-multi-threaded-node-implementation",children:"Exercise 5.1: Multi-threaded Node Implementation"}),"\n",(0,t.jsx)(r.p,{children:"Create a multi-threaded node that:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Processes sensor data in one thread"}),"\n",(0,t.jsx)(r.li,{children:"Performs planning in another thread"}),"\n",(0,t.jsx)(r.li,{children:"Executes control in a third thread"}),"\n",(0,t.jsx)(r.li,{children:"Demonstrates proper thread synchronization"}),"\n",(0,t.jsx)(r.li,{children:"Measures and reports performance"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"exercise-52-optimized-topic-design",children:"Exercise 5.2: Optimized Topic Design"}),"\n",(0,t.jsx)(r.p,{children:"Design an optimized communication system:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Create custom message types for specific use cases"}),"\n",(0,t.jsx)(r.li,{children:"Implement bandwidth optimization techniques"}),"\n",(0,t.jsx)(r.li,{children:"Test with different QoS settings"}),"\n",(0,t.jsx)(r.li,{children:"Measure performance improvements"}),"\n",(0,t.jsx)(r.li,{children:"Document trade-offs"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"exercise-53-robust-service-chain",children:"Exercise 5.3: Robust Service Chain"}),"\n",(0,t.jsx)(r.p,{children:"Implement a service chain with:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Multiple services with dependencies"}),"\n",(0,t.jsx)(r.li,{children:"Error handling and recovery"}),"\n",(0,t.jsx)(r.li,{children:"Retry mechanisms"}),"\n",(0,t.jsx)(r.li,{children:"Performance monitoring"}),"\n",(0,t.jsx)(r.li,{children:"Load balancing strategies"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"exercise-54-advanced-action-workflow",children:"Exercise 5.4: Advanced Action Workflow"}),"\n",(0,t.jsx)(r.p,{children:"Create a multi-stage action system:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Implement custom action interface"}),"\n",(0,t.jsx)(r.li,{children:"Design multi-stage workflow"}),"\n",(0,t.jsx)(r.li,{children:"Add detailed feedback mechanism"}),"\n",(0,t.jsx)(r.li,{children:"Implement cancellation and preemption"}),"\n",(0,t.jsx)(r.li,{children:"Add timeout and retry logic"}),"\n"]}),"\n",(0,t.jsx)(r.h3,{id:"exercise-55-sensor-fusion-system",children:"Exercise 5.5: Sensor Fusion System"}),"\n",(0,t.jsx)(r.p,{children:"Build a complete sensor fusion system:"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsx)(r.li,{children:"Integrate multiple sensor types"}),"\n",(0,t.jsx)(r.li,{children:"Implement Kalman filter for fusion"}),"\n",(0,t.jsx)(r.li,{children:"Handle sensor failures gracefully"}),"\n",(0,t.jsx)(r.li,{children:"Provide performance metrics"}),"\n",(0,t.jsx)(r.li,{children:"Validate with ground truth data"}),"\n"]}),"\n",(0,t.jsx)(r.h2,{id:"glossary-terms",children:"Glossary Terms"}),"\n",(0,t.jsxs)(r.ul,{children:["\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Node Composition"}),": Combining multiple logical nodes into a single process"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Multi-threaded Node"}),": Node using multiple threads for concurrent processing"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Lifecycle Management"}),": Controlled startup, activation, deactivation, and shutdown of nodes"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Bandwidth Optimization"}),": Techniques to reduce data transmission requirements"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Service Chain"}),": Sequence of services where output of one becomes input of next"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Action Workflow"}),": Multi-stage process with feedback and intermediate results"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Sensor Fusion"}),": Combining data from multiple sensors for improved perception"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Kalman Filter"}),": Recursive algorithm for estimating system state from noisy measurements"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"QoS (Quality of Service)"}),": Policies controlling data exchange behavior"]}),"\n",(0,t.jsxs)(r.li,{children:[(0,t.jsx)(r.strong,{children:"Message Serialization"}),": Process of converting message objects to bytes for transmission"]}),"\n"]})]})}function _(e={}){const{wrapper:r}={...(0,a.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>i,x:()=>o});var s=n(6540);const t={},a=s.createContext(t);function i(e){const r=s.useContext(a);return s.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:i(e.components),s.createElement(a.Provider,{value:r},e.children)}}}]);